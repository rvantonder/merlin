{"start":{"line":1,"col":0},"end":{"line":1,"col":9},"definition":{"file":"/Users/rvt/.opam/default/lib/core/core.ml","pos":{"line":1,"col":0}}}
{"start":{"line":1,"col":5},"end":{"line":1,"col":9},"type":"sig\n  module Applicative = Applicative\n  module Avltree = Avltree\n  module Backtrace = Backtrace\n  module Binary_search = Binary_search\n  module Buffer = Base.Buffer\n  module Comparisons = Comparisons\n  module Continue_or_stop = Continue_or_stop\n  module Equal = Equal\n  module Exn = Exn\n  module Expect_test_config = Expect_test_config\n  module Field = Field\n  module Floatable = Floatable\n  module Formatter = Formatter\n  module Hash = Hash\n  module Heap_block = Heap_block\n  module In_channel = In_channel\n  module Int_conversions = Int_conversions\n  module Invariant = Invariant\n  module Monad = Monad\n  module Variant = Variant\n  module Obj_array = Base.Not_exposed_properly.Obj_array\n  module Ordered_collection_common = Ordered_collection_common\n  module Out_channel = Out_channel\n  module Poly = Poly\n  module Polymorphic_compare = Poly\n  module Pretty_printer = Pretty_printer\n  module Random = Base.Random\n  module Sexp_maybe = Sexp_maybe\n  module Staged = Staged\n  module Stringable = Stringable\n  module Uchar = Base.Uchar\n  module Validate = Validate\n  module With_return = With_return\n  module Word_size = Word_size\n  module Array = Core.Array\n  module Binary_searchable = Binary_searchable\n  module Blit = Blit\n  module Bool = Bool\n  module Bytes = Core.Bytes\n  module Char = Core.Char\n  module Comparable = Comparable\n  module Comparator = Comparator\n  module Container = Container\n  module Either = Either\n  module Error = Error\n  module Float = Core.Float\n  module Fn = Fn\n  module Hash_set = Hash_set\n  module Hashtbl = Core.Hashtbl\n  module Hashtbl_intf = Hashtbl_intf\n  module Info = Info\n  module Int = Int\n  module Int_intf = Int_intf\n  module Int32 = Core.Int32\n  module Int63 = Int63\n  module Int64 = Core.Int64\n  module Lazy = Core.Lazy\n  module Linked_queue = Linked_queue\n  module List = Core.List\n  module Maybe_bound = Maybe_bound\n  module Nativeint = Core.Nativeint\n  module Option = Option\n  module Ordering = Ordering\n  module Or_error = Or_error\n  module Printf = Core.Printf\n  module Ref = Ref\n  module Result = Core.Result\n  module Sequence = Sequence\n  module Set = Core.Set\n  module Sexp = Sexp\n  module Sexpable = Sexpable\n  module Sign = Sign\n  module Sign_or_nan = Sign_or_nan\n  module Source_code_position = Source_code_position\n  module String = Core.String\n  module Type_equal = Type_equal\n  module Unit = Unit\n  module Arg = Core.Arg\n  module Bag = Bag\n  module Bigbuffer = Bigbuffer\n  module Bigsubstring = Bigsubstring\n  module Binable = Binable\n  module Bin_prot = Core.Bin_prot\n  module Blang = Blang\n  module Bounded_index = Bounded_index\n  module Bounded_int_table = Bounded_int_table\n  module Bus = Bus\n  module Byte_units = Byte_units\n  module Day_of_week = Day_of_week\n  module Debug = Debug\n  module Deque = Deque\n  module Deriving_hash = Deriving_hash\n  module Doubly_linked = Doubly_linked\n  module Ephemeron = Core.Ephemeron\n  module Fdeque = Fdeque\n  module Flags = Flags\n  module Float_with_finite_only_serialization =\n    Float_with_finite_only_serialization\n  module Fqueue = Fqueue\n  module Gc = Core.Gc\n  module Hash_queue = Hash_queue\n  module Hashable = Hashable\n  module Heap = Heap\n  module Hexdump = Hexdump\n  module Hexdump_intf = Hexdump_intf\n  module Host_and_port = Host_and_port\n  module Identifiable = Identifiable\n  module Immediate_option = Immediate_option\n  module Immediate_option_intf = Immediate_option_intf\n  module Interfaces = Interfaces\n  module Linked_stack = Linked_stack\n  module Map = Core.Map\n  module Md5 = Md5\n  module Memo = Memo\n  module Month = Month\n  module No_polymorphic_compare = No_polymorphic_compare\n  module Nothing = Nothing\n  module Only_in_test = Only_in_test\n  module Option_array = Option_array\n  module Optional_syntax = Optional_syntax\n  module Percent = Percent\n  module Perms = Perms\n  module Pid = Pid\n  module Pool = Pool\n  module Pool_intf = Pool_intf\n  module Popcount = Base__Popcount\n  module Printexc = Core.Printexc\n  module Queue = Core.Queue\n  module Quickcheck = Quickcheck\n  module Quickcheck_intf = Quickcheck_intf\n  module Quickcheckable = Quickcheckable\n  module Robustly_comparable = Robustly_comparable\n  module Set_once = Set_once\n  module Splittable_random = Splittable_random\n  module Stable_comparable = Stable_comparable\n  module Stable_unit_test = Stable_unit_test\n  module Stack = Core.Stack\n  module String_id = String_id\n  module Substring = Substring\n  module Substring_intf = Substring_intf\n  module Timing_wheel_ns = Timing_wheel_ns\n  module Tuple = Tuple\n  module Tuple_type = Tuple_type\n  module Tuple2 = Tuple2\n  module Tuple3 = Tuple3\n  module Type_immediacy = Type_immediacy\n  module Uniform_array = Uniform_array\n  module Union_find = Union_find\n  module Unique_id = Unique_id\n  module Unit_of_time = Unit_of_time\n  module Univ = Univ\n  module Univ_map = Univ_map\n  module Validated = Validated\n  module Weak = Weak\n  module type Unique_id = Unique_id\n  module type T = sig type t end\n  module type T1 = sig type 'a t end\n  module type T2 = sig type ('a, 'b) t end\n  module type T3 = sig type ('a, 'b, 'c) t end\n  module type T_bin =\n    sig\n      type t\n      val bin_size_t : t Bin_prot.Size.sizer\n      val bin_write_t : t Bin_prot.Write.writer\n      val bin_read_t : t Bin_prot.Read.reader\n      val __bin_read_t__ : (int -> t) Bin_prot.Read.reader\n      val bin_shape_t : Bin_prot.Shape.t\n      val bin_writer_t : t Bin_prot.Type_class.writer\n      val bin_reader_t : t Bin_prot.Type_class.reader\n      val bin_t : t Bin_prot.Type_class.t\n    end\n  type 'a _maybe_bound =\n    'a Maybe_bound.t =\n      Incl of 'a\n    | Excl of 'a\n    | Unbounded\n  val does_raise : (unit -> 'a) -> sexp_bool\n  val am_running_inline_test : sexp_bool\n  val am_running_test : sexp_bool\n  external raise : exn -> 'a = \"%reraise\"\n  external raise_notrace : exn -> 'a = \"%raise_notrace\"\n  val invalid_arg : string -> 'a\n  val failwith : string -> 'a\n  exception Exit\n  external ( = ) : 'a -> 'a -> sexp_bool = \"%equal\"\n  external ( <> ) : 'a -> 'a -> sexp_bool = \"%notequal\"\n  external ( < ) : 'a -> 'a -> sexp_bool = \"%lessthan\"\n  external ( > ) : 'a -> 'a -> sexp_bool = \"%greaterthan\"\n  external ( <= ) : 'a -> 'a -> sexp_bool = \"%lessequal\"\n  external ( >= ) : 'a -> 'a -> sexp_bool = \"%greaterequal\"\n  external compare : 'a -> 'a -> int = \"%compare\"\n  val min : 'a -> 'a -> 'a\n  val max : 'a -> 'a -> 'a\n  external ( == ) : 'a -> 'a -> sexp_bool = \"%eq\"\n  external ( != ) : 'a -> 'a -> sexp_bool = \"%noteq\"\n  external not : sexp_bool -> sexp_bool = \"%boolnot\"\n  external ( && ) : sexp_bool -> sexp_bool -> sexp_bool = \"%sequand\"\n  external ( & ) : sexp_bool -> sexp_bool -> sexp_bool = \"%sequand\"\n  external ( || ) : sexp_bool -> sexp_bool -> sexp_bool = \"%sequor\"\n  external ( or ) : sexp_bool -> sexp_bool -> sexp_bool = \"%sequor\"\n  external __LOC__ : string = \"%loc_LOC\"\n  external __FILE__ : string = \"%loc_FILE\"\n  external __LINE__ : int = \"%loc_LINE\"\n  external __MODULE__ : string = \"%loc_MODULE\"\n  external __POS__ : string * int * int * int = \"%loc_POS\"\n  external __LOC_OF__ : 'a -> string * 'a = \"%loc_LOC\"\n  external __LINE_OF__ : 'a -> int * 'a = \"%loc_LINE\"\n  external __POS_OF__ : 'a -> (string * int * int * int) * 'a = \"%loc_POS\"\n  external ( |> ) : 'a -> ('a -> 'b) -> 'b = \"%revapply\"\n  external ( @@ ) : ('a -> 'b) -> 'a -> 'b = \"%apply\"\n  external ( ~- ) : int -> int = \"%negint\"\n  external ( ~+ ) : int -> int = \"%identity\"\n  external succ : int -> int = \"%succint\"\n  external pred : int -> int = \"%predint\"\n  external ( + ) : int -> int -> int = \"%addint\"\n  external ( - ) : int -> int -> int = \"%subint\"\n  external ( * ) : int -> int -> int = \"%mulint\"\n  external ( / ) : int -> int -> int = \"%divint\"\n  external ( mod ) : int -> int -> int = \"%modint\"\n  val abs : int -> int\n  val max_int : int\n  val min_int : int\n  external ( land ) : int -> int -> int = \"%andint\"\n  external ( lor ) : int -> int -> int = \"%orint\"\n  external ( lxor ) : int -> int -> int = \"%xorint\"\n  val lnot : int -> int\n  external ( lsl ) : int -> int -> int = \"%lslint\"\n  external ( lsr ) : int -> int -> int = \"%lsrint\"\n  external ( asr ) : int -> int -> int = \"%asrint\"\n  external ( ~-. ) : float -> float = \"%negfloat\"\n  external ( ~+. ) : float -> float = \"%identity\"\n  external ( +. ) : float -> float -> float = \"%addfloat\"\n  external ( -. ) : float -> float -> float = \"%subfloat\"\n  external ( *. ) : float -> float -> float = \"%mulfloat\"\n  external ( /. ) : float -> float -> float = \"%divfloat\"\n  external ( ** ) : float -> float -> float = \"caml_power_float\" \"pow\"\n    [@@unboxed] [@@noalloc]\n  external sqrt : float -> float = \"caml_sqrt_float\" \"sqrt\" [@@unboxed]\n    [@@noalloc]\n  external exp : float -> float = \"caml_exp_float\" \"exp\" [@@unboxed]\n    [@@noalloc]\n  external log : float -> float = \"caml_log_float\" \"log\" [@@unboxed]\n    [@@noalloc]\n  external log10 : float -> float = \"caml_log10_float\" \"log10\" [@@unboxed]\n    [@@noalloc]\n  external expm1 : float -> float = \"caml_expm1_float\" \"caml_expm1\"\n    [@@unboxed] [@@noalloc]\n  external log1p : float -> float = \"caml_log1p_float\" \"caml_log1p\"\n    [@@unboxed] [@@noalloc]\n  external cos : float -> float = \"caml_cos_float\" \"cos\" [@@unboxed]\n    [@@noalloc]\n  external sin : float -> float = \"caml_sin_float\" \"sin\" [@@unboxed]\n    [@@noalloc]\n  external tan : float -> float = \"caml_tan_float\" \"tan\" [@@unboxed]\n    [@@noalloc]\n  external acos : float -> float = \"caml_acos_float\" \"acos\" [@@unboxed]\n    [@@noalloc]\n  external asin : float -> float = \"caml_asin_float\" \"asin\" [@@unboxed]\n    [@@noalloc]\n  external atan : float -> float = \"caml_atan_float\" \"atan\" [@@unboxed]\n    [@@noalloc]\n  external atan2 : float -> float -> float = \"caml_atan2_float\" \"atan2\"\n    [@@unboxed] [@@noalloc]\n  external hypot : float -> float -> float = \"caml_hypot_float\" \"caml_hypot\"\n    [@@unboxed] [@@noalloc]\n  external cosh : float -> float = \"caml_cosh_float\" \"cosh\" [@@unboxed]\n    [@@noalloc]\n  external sinh : float -> float = \"caml_sinh_float\" \"sinh\" [@@unboxed]\n    [@@noalloc]\n  external tanh : float -> float = \"caml_tanh_float\" \"tanh\" [@@unboxed]\n    [@@noalloc]\n  external ceil : float -> float = \"caml_ceil_float\" \"ceil\" [@@unboxed]\n    [@@noalloc]\n  external floor : float -> float = \"caml_floor_float\" \"floor\" [@@unboxed]\n    [@@noalloc]\n  external abs_float : float -> float = \"%absfloat\"\n  external copysign : float -> float -> float = \"caml_copysign_float\"\n    \"caml_copysign\" [@@unboxed] [@@noalloc]\n  external mod_float : float -> float -> float = \"caml_fmod_float\" \"fmod\"\n    [@@unboxed] [@@noalloc]\n  external frexp : float -> float * int = \"caml_frexp_float\"\n  external ldexp :\n    (float [@unboxed]) -> (int [@untagged]) -> (float [@unboxed])\n    = \"caml_ldexp_float\" \"caml_ldexp_float_unboxed\" [@@noalloc]\n  external modf : float -> float * float = \"caml_modf_float\"\n  external float : int -> float = \"%floatofint\"\n  external float_of_int : int -> float = \"%floatofint\"\n  external truncate : float -> int = \"%intoffloat\"\n  external int_of_float : float -> int = \"%intoffloat\"\n  val infinity : float\n  val neg_infinity : float\n  val nan : float\n  val max_float : float\n  val min_float : float\n  val epsilon_float : float\n  type fpclass =\n    Pervasives.fpclass =\n      FP_normal\n    | FP_subnormal\n    | FP_zero\n    | FP_infinite\n    | FP_nan\n  external classify_float : (float [@unboxed]) -> fpclass\n    = \"caml_classify_float\" \"caml_classify_float_unboxed\" [@@noalloc]\n  val ( ^ ) : string -> string -> string\n  external int_of_char : char -> int = \"%identity\"\n  val char_of_int : int -> char\n  external ignore : 'a -> unit = \"%ignore\"\n  val string_of_bool : sexp_bool -> string\n  val bool_of_string : string -> sexp_bool\n  val string_of_int : int -> string\n  external int_of_string : string -> int = \"caml_int_of_string\"\n  val string_of_float : float -> string\n  external float_of_string : string -> float = \"caml_float_of_string\"\n  external fst : 'a * 'b -> 'a = \"%field0\"\n  external snd : 'a * 'b -> 'b = \"%field1\"\n  type in_channel = Pervasives.in_channel\n  type out_channel = Pervasives.out_channel\n  val stdin : Pervasives.in_channel\n  val stdout : Pervasives.out_channel\n  val stderr : Pervasives.out_channel\n  val print_char : char -> unit\n  val print_string : string -> unit\n  val print_bytes : string -> unit\n  val print_int : int -> unit\n  val print_float : float -> unit\n  val print_endline : string -> unit\n  val print_newline : unit -> unit\n  val prerr_char : char -> unit\n  val prerr_string : string -> unit\n  val prerr_bytes : string -> unit\n  val prerr_int : int -> unit\n  val prerr_float : float -> unit\n  val prerr_endline : string -> unit\n  val prerr_newline : unit -> unit\n  val read_line : unit -> string\n  val read_int : unit -> int\n  val read_float : unit -> float\n  type open_flag =\n    Pervasives.open_flag =\n      Open_rdonly\n    | Open_wronly\n    | Open_append\n    | Open_creat\n    | Open_trunc\n    | Open_excl\n    | Open_binary\n    | Open_text\n    | Open_nonblock\n  val open_out : string -> Pervasives.out_channel\n  val open_out_bin : string -> Pervasives.out_channel\n  val open_out_gen :\n    Pervasives.open_flag sexp_list -> int -> string -> Pervasives.out_channel\n  val flush : Pervasives.out_channel -> unit\n  val flush_all : unit -> unit\n  val output_char : Pervasives.out_channel -> char -> unit\n  val output_string : Pervasives.out_channel -> string -> unit\n  val output_bytes : Pervasives.out_channel -> string -> unit\n  val output : Pervasives.out_channel -> string -> int -> int -> unit\n  val output_substring :\n    Pervasives.out_channel -> string -> int -> int -> unit\n  val output_byte : Pervasives.out_channel -> int -> unit\n  val output_binary_int : Pervasives.out_channel -> int -> unit\n  val output_value : Pervasives.out_channel -> 'a -> unit\n  val seek_out : Pervasives.out_channel -> int -> unit\n  val pos_out : Pervasives.out_channel -> int\n  val out_channel_length : Pervasives.out_channel -> int\n  val close_out : Pervasives.out_channel -> unit\n  val close_out_noerr : Pervasives.out_channel -> unit\n  val set_binary_mode_out : Pervasives.out_channel -> sexp_bool -> unit\n  val open_in : string -> Pervasives.in_channel\n  val open_in_bin : string -> Pervasives.in_channel\n  val open_in_gen :\n    Pervasives.open_flag sexp_list -> int -> string -> Pervasives.in_channel\n  val input_char : Pervasives.in_channel -> char\n  val input_line : Pervasives.in_channel -> string\n  val input : Pervasives.in_channel -> string -> int -> int -> int\n  val really_input : Pervasives.in_channel -> string -> int -> int -> unit\n  val really_input_string : Pervasives.in_channel -> int -> string\n  val input_byte : Pervasives.in_channel -> int\n  val input_binary_int : Pervasives.in_channel -> int\n  val input_value : Pervasives.in_channel -> 'a\n  val seek_in : Pervasives.in_channel -> int -> unit\n  val pos_in : Pervasives.in_channel -> int\n  val in_channel_length : Pervasives.in_channel -> int\n  val close_in : Pervasives.in_channel -> unit\n  val close_in_noerr : Pervasives.in_channel -> unit\n  val set_binary_mode_in : Pervasives.in_channel -> sexp_bool -> unit\n  module LargeFile = Core_kernel__Core_pervasives.LargeFile\n  type 'a ref = 'a Pervasives.ref = { mutable contents : 'a; }\n  external ref : 'a -> 'a ref = \"%makemutable\"\n  external ( ! ) : 'a ref -> 'a = \"%field0\"\n  external ( := ) : 'a ref -> 'a -> unit = \"%setfield0\"\n  external incr : int ref -> unit = \"%incr\"\n  external decr : int ref -> unit = \"%decr\"\n  type ('a, 'b) result = ('a, 'b) Pervasives.result = Ok of 'a | Error of 'b\n  type ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n      ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n  type ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6\n  type ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4\n  val string_of_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string\n  external format_of_string :\n    ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6\n    = \"%identity\"\n  val ( ^^ ) :\n    ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n    ('f, 'b, 'c, 'e, 'g, 'h) format6 -> ('a, 'b, 'c, 'd, 'g, 'h) format6\n  val exit : int -> 'a\n  val at_exit : (unit -> unit) -> unit\n  val valid_float_lexem : string -> string\n  val unsafe_really_input :\n    Pervasives.in_channel -> string -> int -> int -> unit\n  val do_at_exit : unit -> unit\n  val quickcheck_generator_unit : Base.unit Base_quickcheck__.Generator.t\n  val quickcheck_generator_bool : sexp_bool Base_quickcheck__.Generator.t\n  val quickcheck_generator_char : Base.char Base_quickcheck__.Generator.t\n  val quickcheck_generator_string : string Base_quickcheck__.Generator.t\n  val quickcheck_generator_int : Base.int Base_quickcheck__.Generator.t\n  val quickcheck_generator_int32 : Base.int32 Base_quickcheck__.Generator.t\n  val quickcheck_generator_int64 : Base.int64 Base_quickcheck__.Generator.t\n  val quickcheck_generator_nativeint :\n    Base.nativeint Base_quickcheck__.Generator.t\n  val quickcheck_generator_float : Base.float Base_quickcheck__.Generator.t\n  val quickcheck_observer_unit : Base.unit Base_quickcheck__.Observer.t\n  val quickcheck_observer_bool : sexp_bool Base_quickcheck__.Observer.t\n  val quickcheck_observer_char : Base.char Base_quickcheck__.Observer.t\n  val quickcheck_observer_string : string Base_quickcheck__.Observer.t\n  val quickcheck_observer_int : Base.int Base_quickcheck__.Observer.t\n  val quickcheck_observer_int32 : Base.int32 Base_quickcheck__.Observer.t\n  val quickcheck_observer_int64 : Base.int64 Base_quickcheck__.Observer.t\n  val quickcheck_observer_nativeint :\n    Base.nativeint Base_quickcheck__.Observer.t\n  val quickcheck_observer_float : Base.float Base_quickcheck__.Observer.t\n  val quickcheck_shrinker_unit : Base.unit Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_bool : sexp_bool Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_char : Base.char Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_string : string Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_int : Base.int Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_int32 : Base.int32 Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_int64 : Base.int64 Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_nativeint :\n    Base.nativeint Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_float : Base.float Base_quickcheck__.Shrinker.t\n  val quickcheck_generator_option :\n    'a Base_quickcheck__.Generator.t ->\n    'a sexp_option Base_quickcheck__.Generator.t\n  val quickcheck_generator_list :\n    'a Base_quickcheck__.Generator.t ->\n    'a sexp_list Base_quickcheck__.Generator.t\n  val quickcheck_observer_option :\n    'a Base_quickcheck__.Observer.t ->\n    'a sexp_option Base_quickcheck__.Observer.t\n  val quickcheck_observer_list :\n    'a Base_quickcheck__.Observer.t ->\n    'a sexp_list Base_quickcheck__.Observer.t\n  val quickcheck_shrinker_option :\n    'a Base_quickcheck__.Shrinker.t ->\n    'a sexp_option Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_list :\n    'a Base_quickcheck__.Shrinker.t ->\n    'a sexp_list Base_quickcheck__.Shrinker.t\n  val ( |! ) : 'a -> ('a -> 'b) -> 'b\n  type ('f, 's) _either = ('f, 's) Base.Either.t = First of 'f | Second of 's\n  val ( >=. ) : Base.float -> Base.float -> sexp_bool\n  val ( <=. ) : Base.float -> Base.float -> sexp_bool\n  val ( =. ) : Base.float -> Base.float -> sexp_bool\n  val ( >. ) : Base.float -> Base.float -> sexp_bool\n  val ( <. ) : Base.float -> Base.float -> sexp_bool\n  val ( <>. ) : Base.float -> Base.float -> sexp_bool\n  val robustly_compare : Base.float -> Base.float -> int\n  type bigstring = Core.bigstring\n  val sexp_of_bigstring : bigstring -> Ppx_sexp_conv_lib.Sexp.t\n  val bigstring_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> bigstring\n  type mat = Core.mat\n  val sexp_of_mat : mat -> Ppx_sexp_conv_lib.Sexp.t\n  val mat_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> mat\n  type vec = Core.vec\n  val sexp_of_vec : vec -> Ppx_sexp_conv_lib.Sexp.t\n  val vec_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> vec\n  val sexp_of_opaque : 'a -> Ppx_sexp_conv_lib.Sexp.t\n  val opaque_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> 'a\n  val sexp_of_pair :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    ('b -> Ppx_sexp_conv_lib.Sexp.t) -> 'a * 'b -> Ppx_sexp_conv_lib.Sexp.t\n  val pair_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    (Ppx_sexp_conv_lib.Sexp.t -> 'b) -> Ppx_sexp_conv_lib.Sexp.t -> 'a * 'b\n  exception Of_sexp_error of Exn.t * Ppx_sexp_conv_lib.Sexp.t\n  val of_sexp_error : string -> Ppx_sexp_conv_lib.Sexp.t -> 'a\n  val of_sexp_error_exn : Exn.t -> Ppx_sexp_conv_lib.Sexp.t -> 'a\n  module type Applicative = Applicative\n  module type Binable = Binable\n  module type Comparable = Comparable\n  module type Comparable_binable = Comparable_binable\n  module type Floatable = Floatable\n  module type Hashable = Hashable\n  module type Hashable_binable = Hashable_binable\n  module type Identifiable = Identifiable\n  module type Infix_comparators = Infix_comparators\n  module type Intable = Intable\n  module type Monad = Monad\n  module type Quickcheckable = Quickcheckable\n  module type Robustly_comparable = Robustly_comparable\n  module type Sexpable = Sexpable\n  module type Stable = Stable\n  module type Stable_int63able = Stable_int63able\n  module type Stable_without_comparator = Stable_without_comparator\n  module type Stable1 = Stable1\n  module type Stable2 = Stable2\n  module type Stable3 = Stable3\n  module type Stable4 = Stable4\n  module type Stringable = Stringable\n  module type Unit = Unit\n  val ( @ ) : 'a sexp_list -> 'a sexp_list -> 'a sexp_list\n  type never_returns = Nothing.t\n  val sexp_of_never_returns : never_returns -> Ppx_sexp_conv_lib.Sexp.t\n  val never_returns : never_returns -> 'a\n  type _ordering = Ordering.t = Less | Equal | Greater\n  type read = Core.read\n  val bin_shape_read : Bin_prot.Shape.t\n  val bin_size_read : read Bin_prot.Size.sizer\n  val bin_write_read : read Bin_prot.Write.writer\n  val bin_writer_read : read Bin_prot.Type_class.writer\n  val bin_read_read : read Bin_prot.Read.reader\n  val __bin_read_read__ : (Base.int -> read) Bin_prot.Read.reader\n  val bin_reader_read : read Bin_prot.Type_class.reader\n  val bin_read : read Bin_prot.Type_class.t\n  val compare_read : read -> read -> Base.int\n  val hash_fold_read :\n    Ppx_hash_lib.Std.Hash.state -> read -> Ppx_hash_lib.Std.Hash.state\n  val hash_read : read -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_read : read -> Ppx_sexp_conv_lib.Sexp.t\n  val read_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> read\n  type write = Core.write\n  val compare_write : write -> write -> Base.int\n  val hash_fold_write :\n    Ppx_hash_lib.Std.Hash.state -> write -> Ppx_hash_lib.Std.Hash.state\n  val hash_write : write -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_write : write -> Ppx_sexp_conv_lib.Sexp.t\n  val write_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> write\n  type immutable = Core.immutable\n  val bin_shape_immutable : Bin_prot.Shape.t\n  val bin_size_immutable : immutable Bin_prot.Size.sizer\n  val bin_write_immutable : immutable Bin_prot.Write.writer\n  val bin_writer_immutable : immutable Bin_prot.Type_class.writer\n  val bin_read_immutable : immutable Bin_prot.Read.reader\n  val __bin_read_immutable__ : (Base.int -> immutable) Bin_prot.Read.reader\n  val bin_reader_immutable : immutable Bin_prot.Type_class.reader\n  val bin_immutable : immutable Bin_prot.Type_class.t\n  val compare_immutable : immutable -> immutable -> Base.int\n  val hash_fold_immutable :\n    Ppx_hash_lib.Std.Hash.state -> immutable -> Ppx_hash_lib.Std.Hash.state\n  val hash_immutable : immutable -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_immutable : immutable -> Ppx_sexp_conv_lib.Sexp.t\n  val immutable_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> immutable\n  type read_write = Core.read_write\n  val bin_shape_read_write : Bin_prot.Shape.t\n  val bin_size_read_write : read_write Bin_prot.Size.sizer\n  val bin_write_read_write : read_write Bin_prot.Write.writer\n  val bin_writer_read_write : read_write Bin_prot.Type_class.writer\n  val bin_read_read_write : read_write Bin_prot.Read.reader\n  val __bin_read_read_write__ : (Base.int -> read_write) Bin_prot.Read.reader\n  val bin_reader_read_write : read_write Bin_prot.Type_class.reader\n  val bin_read_write : read_write Bin_prot.Type_class.t\n  val compare_read_write : read_write -> read_write -> Base.int\n  val hash_fold_read_write :\n    Ppx_hash_lib.Std.Hash.state -> read_write -> Ppx_hash_lib.Std.Hash.state\n  val hash_read_write : read_write -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_read_write : read_write -> Ppx_sexp_conv_lib.Sexp.t\n  val read_write_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> read_write\n  type 'a perms = 'a Core.perms\n  val bin_shape_perms : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_perms : 'a Bin_prot.Size.sizer -> 'a perms Bin_prot.Size.sizer\n  val bin_write_perms :\n    'a Bin_prot.Write.writer -> 'a perms Bin_prot.Write.writer\n  val bin_writer_perms :\n    'a Bin_prot.Type_class.writer -> 'a perms Bin_prot.Type_class.writer\n  val bin_read_perms :\n    'a Bin_prot.Read.reader -> 'a perms Bin_prot.Read.reader\n  val __bin_read_perms__ :\n    'a Bin_prot.Read.reader -> (Base.int -> 'a perms) Bin_prot.Read.reader\n  val bin_reader_perms :\n    'a Bin_prot.Type_class.reader -> 'a perms Bin_prot.Type_class.reader\n  val bin_perms : 'a Bin_prot.Type_class.t -> 'a perms Bin_prot.Type_class.t\n  val compare_perms :\n    ('a -> 'a -> Base.int) -> 'a perms -> 'a perms -> Base.int\n  val hash_fold_perms :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state -> 'a perms -> Ppx_hash_lib.Std.Hash.state\n  val sexp_of_perms :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'a perms -> Ppx_sexp_conv_lib.Sexp.t\n  val perms_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) -> Ppx_sexp_conv_lib.Sexp.t -> 'a perms\n  type ('ok, 'err) _result = ('ok, 'err) Result.t = Ok of 'ok | Error of 'err\n  val is_ok : ('a, 'b) Result.t -> sexp_bool\n  val is_error : ('a, 'b) Result.t -> sexp_bool\n  type -'a return =\n    'a With_return.return = private {\n    return : 'b. 'a -> 'b;\n  } [@@unboxed]\n  exception Bug of string\n  exception C_malloc_exn of Base.int * Base.int\n  exception Finally of Exn.t * Exn.t\n  val fst3 : 'a * 'b * 'c -> 'a\n  val snd3 : 'a * 'b * 'c -> 'b\n  val trd3 : 'a * 'b * 'c -> 'c\n  val uw : 'a sexp_option -> 'a\n  val ( % ) : int -> int -> int\n  val ( /% ) : int -> int -> int\n  val ( // ) : int -> int -> float\n  val ( ==> ) : sexp_bool -> sexp_bool -> sexp_bool\n  val bprintf :\n    Base__Import0.Caml.Buffer.t ->\n    ('a, Base__Import0.Caml.Buffer.t, unit) format -> 'a\n  val const : 'a -> 'b -> 'a\n  val eprintf : ('a, Stdio.Out_channel.t, Base.unit) format -> 'a\n  val error :\n    ?strict:unit -> string -> 'a -> ('a -> Base__Sexp.t) -> 'b Or_error.t\n  val error_s : Base__Sexp.t -> 'a Or_error.t\n  val failwithf : ('a, unit, string, unit -> 'b) format4 -> 'a\n  val failwithp :\n    ?strict:Base.unit ->\n    Lexing.position -> string -> 'a -> ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'b\n  val failwiths :\n    ?strict:Base.unit ->\n    ?here:Lexing.position ->\n    string -> 'a -> ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'b\n  val force : 'a Base.Lazy.t -> 'a\n  val fprintf :\n    Stdio.Out_channel.t -> ('a, Stdio.Out_channel.t, Base.unit) format -> 'a\n  val ident : 'a -> 'a\n  val invalid_argf : ('a, unit, string, unit -> 'b) format4 -> 'a\n  val ifprintf : 'a -> ('b, 'a, 'c, unit) format4 -> 'b\n  val is_none : 'a sexp_option -> sexp_bool\n  val is_some : 'a sexp_option -> sexp_bool\n  val ksprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b\n  val ok_exn : 'a Or_error.t -> 'a\n  val phys_equal : 'a -> 'a -> sexp_bool\n  val phys_same : 'a -> 'b -> sexp_bool\n  val print_s : ?mach:Base.unit -> Ppx_sexp_conv_lib.Sexp.t -> Base.unit\n  val printf : ('a, Stdio.Out_channel.t, Base.unit) format -> 'a\n  val protect : f:(unit -> 'a) -> finally:(unit -> unit) -> 'a\n  val protectx : f:('a -> 'b) -> 'a -> finally:('a -> unit) -> 'b\n  val raise_s : Base__Sexp.t -> 'a\n  val round : ?dir:[ `Down | `Nearest | `Up | `Zero ] -> Float.t -> Float.t\n  val ( **. ) : Base.float -> Base.float -> Base.float\n  val sprintf : ('a, unit, string) format -> 'a\n  val stage : 'a -> 'a Staged.t\n  val unstage : 'a Staged.t -> 'a\n  val with_return : ('a return -> 'a) -> 'a\n  val with_return_option : ('a return -> unit) -> 'a sexp_option\n  module Typerep = Typerep\n  type tuple0 = Core.tuple0\n  val value_tuple0 : tuple0\n  val typerep_of_function :\n    'a Typerep.t -> 'b Typerep.t -> ('a -> 'b) Typerep.t\n  val typerep_of_tuple0 : tuple0 Typerep.t\n  val typerep_of_tuple2 : 'a Typerep.t -> 'b Typerep.t -> ('a * 'b) Typerep.t\n  val typerep_of_tuple3 :\n    'a Typerep.t -> 'b Typerep.t -> 'c Typerep.t -> ('a * 'b * 'c) Typerep.t\n  val typerep_of_tuple4 :\n    'a Typerep.t ->\n    'b Typerep.t ->\n    'c Typerep.t -> 'd Typerep.t -> ('a * 'b * 'c * 'd) Typerep.t\n  val typerep_of_tuple5 :\n    'a Typerep.t ->\n    'b Typerep.t ->\n    'c Typerep.t ->\n    'd Typerep.t -> 'e Typerep.t -> ('a * 'b * 'c * 'd * 'e) Typerep.t\n  val typename_of_function :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t -> ('a -> 'b) Typerep_lib.Typename.t\n  val typename_of_tuple0 : tuple0 Typerep_lib.Typename.t\n  val typename_of_tuple2 :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t -> ('a * 'b) Typerep_lib.Typename.t\n  val typename_of_tuple3 :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t ->\n    'c Typerep_lib.Typename.t -> ('a * 'b * 'c) Typerep_lib.Typename.t\n  val typename_of_tuple4 :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t ->\n    'c Typerep_lib.Typename.t ->\n    'd Typerep_lib.Typename.t -> ('a * 'b * 'c * 'd) Typerep_lib.Typename.t\n  val typename_of_tuple5 :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t ->\n    'c Typerep_lib.Typename.t ->\n    'd Typerep_lib.Typename.t ->\n    'e Typerep_lib.Typename.t ->\n    ('a * 'b * 'c * 'd * 'e) Typerep_lib.Typename.t\n  val bin_shape_array : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_array :\n    'a Bin_prot.Size.sizer -> 'a sexp_array Bin_prot.Size.sizer\n  val bin_write_array :\n    'a Bin_prot.Write.writer -> 'a sexp_array Bin_prot.Write.writer\n  val bin_writer_array :\n    'a Bin_prot.Type_class.writer -> 'a sexp_array Bin_prot.Type_class.writer\n  val bin_read_array :\n    'a Bin_prot.Read.reader -> 'a sexp_array Bin_prot.Read.reader\n  val __bin_read_array__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_array) Bin_prot.Read.reader\n  val bin_reader_array :\n    'a Bin_prot.Type_class.reader -> 'a sexp_array Bin_prot.Type_class.reader\n  val bin_array :\n    'a Bin_prot.Type_class.t -> 'a sexp_array Bin_prot.Type_class.t\n  val compare_array :\n    ('a -> 'a -> Base.int) -> 'a sexp_array -> 'a sexp_array -> Base.int\n  val equal_array :\n    ('a -> 'a -> sexp_bool) -> 'a sexp_array -> 'a sexp_array -> sexp_bool\n  val sexp_of_array :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a sexp_array -> Ppx_sexp_conv_lib.Sexp.t\n  val array_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a sexp_array\n  val typerep_of_array :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_array Typerep_lib.Std.Typerep.t\n  val typename_of_array :\n    'a Typerep_lib.Std.Typename.t -> 'a sexp_array Typerep_lib.Std.Typename.t\n  val bin_shape_bool : Bin_prot.Shape.t\n  val bin_size_bool : sexp_bool Bin_prot.Size.sizer\n  val bin_write_bool : sexp_bool Bin_prot.Write.writer\n  val bin_writer_bool : sexp_bool Bin_prot.Type_class.writer\n  val bin_read_bool : sexp_bool Bin_prot.Read.reader\n  val __bin_read_bool__ : (Base.int -> sexp_bool) Bin_prot.Read.reader\n  val bin_reader_bool : sexp_bool Bin_prot.Type_class.reader\n  val bin_bool : sexp_bool Bin_prot.Type_class.t\n  val compare_bool : sexp_bool -> sexp_bool -> Base.int\n  val equal_bool : sexp_bool -> sexp_bool -> sexp_bool\n  val hash_fold_bool :\n    Ppx_hash_lib.Std.Hash.state -> sexp_bool -> Ppx_hash_lib.Std.Hash.state\n  val hash_bool : sexp_bool -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_bool : sexp_bool -> Ppx_sexp_conv_lib.Sexp.t\n  val bool_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> sexp_bool\n  val typerep_of_bool : sexp_bool Typerep_lib.Std.Typerep.t\n  val typename_of_bool : sexp_bool Typerep_lib.Std.Typename.t\n  val bin_shape_char : Bin_prot.Shape.t\n  val bin_size_char : Base.char Bin_prot.Size.sizer\n  val bin_write_char : Base.char Bin_prot.Write.writer\n  val bin_writer_char : Base.char Bin_prot.Type_class.writer\n  val bin_read_char : Base.char Bin_prot.Read.reader\n  val __bin_read_char__ : (Base.int -> Base.char) Bin_prot.Read.reader\n  val bin_reader_char : Base.char Bin_prot.Type_class.reader\n  val bin_char : Base.char Bin_prot.Type_class.t\n  val compare_char : Base.char -> Base.char -> Base.int\n  val equal_char : Base.char -> Base.char -> sexp_bool\n  val hash_fold_char :\n    Ppx_hash_lib.Std.Hash.state -> Base.char -> Ppx_hash_lib.Std.Hash.state\n  val hash_char : Base.char -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_char : Base.char -> Ppx_sexp_conv_lib.Sexp.t\n  val char_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.char\n  val typerep_of_char : Base.char Typerep_lib.Std.Typerep.t\n  val typename_of_char : Base.char Typerep_lib.Std.Typename.t\n  val bin_shape_float : Bin_prot.Shape.t\n  val bin_size_float : Base.float Bin_prot.Size.sizer\n  val bin_write_float : Base.float Bin_prot.Write.writer\n  val bin_writer_float : Base.float Bin_prot.Type_class.writer\n  val bin_read_float : Base.float Bin_prot.Read.reader\n  val __bin_read_float__ : (Base.int -> Base.float) Bin_prot.Read.reader\n  val bin_reader_float : Base.float Bin_prot.Type_class.reader\n  val bin_float : Base.float Bin_prot.Type_class.t\n  val compare_float : Base.float -> Base.float -> Base.int\n  val equal_float : Base.float -> Base.float -> sexp_bool\n  val hash_fold_float :\n    Ppx_hash_lib.Std.Hash.state -> Base.float -> Ppx_hash_lib.Std.Hash.state\n  val hash_float : Base.float -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_float : Base.float -> Ppx_sexp_conv_lib.Sexp.t\n  val float_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.float\n  val typerep_of_float : Base.float Typerep_lib.Std.Typerep.t\n  val typename_of_float : Base.float Typerep_lib.Std.Typename.t\n  val bin_shape_int : Bin_prot.Shape.t\n  val bin_size_int : Base.int Bin_prot.Size.sizer\n  val bin_write_int : Base.int Bin_prot.Write.writer\n  val bin_writer_int : Base.int Bin_prot.Type_class.writer\n  val bin_read_int : Base.int Bin_prot.Read.reader\n  val __bin_read_int__ : (Base.int -> Base.int) Bin_prot.Read.reader\n  val bin_reader_int : Base.int Bin_prot.Type_class.reader\n  val bin_int : Base.int Bin_prot.Type_class.t\n  val compare_int : Base.int -> Base.int -> Base.int\n  val equal_int : Base.int -> Base.int -> sexp_bool\n  val hash_fold_int :\n    Ppx_hash_lib.Std.Hash.state -> Base.int -> Ppx_hash_lib.Std.Hash.state\n  val hash_int : Base.int -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_int : Base.int -> Ppx_sexp_conv_lib.Sexp.t\n  val int_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.int\n  val typerep_of_int : Base.int Typerep_lib.Std.Typerep.t\n  val typename_of_int : Base.int Typerep_lib.Std.Typename.t\n  val bin_shape_int32 : Bin_prot.Shape.t\n  val bin_size_int32 : Base.int32 Bin_prot.Size.sizer\n  val bin_write_int32 : Base.int32 Bin_prot.Write.writer\n  val bin_writer_int32 : Base.int32 Bin_prot.Type_class.writer\n  val bin_read_int32 : Base.int32 Bin_prot.Read.reader\n  val __bin_read_int32__ : (Base.int -> Base.int32) Bin_prot.Read.reader\n  val bin_reader_int32 : Base.int32 Bin_prot.Type_class.reader\n  val bin_int32 : Base.int32 Bin_prot.Type_class.t\n  val compare_int32 : Base.int32 -> Base.int32 -> Base.int\n  val equal_int32 : Base.int32 -> Base.int32 -> sexp_bool\n  val hash_fold_int32 :\n    Ppx_hash_lib.Std.Hash.state -> Base.int32 -> Ppx_hash_lib.Std.Hash.state\n  val hash_int32 : Base.int32 -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_int32 : Base.int32 -> Ppx_sexp_conv_lib.Sexp.t\n  val int32_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.int32\n  val typerep_of_int32 : Base.int32 Typerep_lib.Std.Typerep.t\n  val typename_of_int32 : Base.int32 Typerep_lib.Std.Typename.t\n  val bin_shape_int64 : Bin_prot.Shape.t\n  val bin_size_int64 : Base.int64 Bin_prot.Size.sizer\n  val bin_write_int64 : Base.int64 Bin_prot.Write.writer\n  val bin_writer_int64 : Base.int64 Bin_prot.Type_class.writer\n  val bin_read_int64 : Base.int64 Bin_prot.Read.reader\n  val __bin_read_int64__ : (Base.int -> Base.int64) Bin_prot.Read.reader\n  val bin_reader_int64 : Base.int64 Bin_prot.Type_class.reader\n  val bin_int64 : Base.int64 Bin_prot.Type_class.t\n  val compare_int64 : Base.int64 -> Base.int64 -> Base.int\n  val equal_int64 : Base.int64 -> Base.int64 -> sexp_bool\n  val hash_fold_int64 :\n    Ppx_hash_lib.Std.Hash.state -> Base.int64 -> Ppx_hash_lib.Std.Hash.state\n  val hash_int64 : Base.int64 -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_int64 : Base.int64 -> Ppx_sexp_conv_lib.Sexp.t\n  val int64_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.int64\n  val typerep_of_int64 : Base.int64 Typerep_lib.Std.Typerep.t\n  val typename_of_int64 : Base.int64 Typerep_lib.Std.Typename.t\n  val bin_shape_lazy_t : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_lazy_t :\n    'a Bin_prot.Size.sizer -> 'a lazy_t Bin_prot.Size.sizer\n  val bin_write_lazy_t :\n    'a Bin_prot.Write.writer -> 'a lazy_t Bin_prot.Write.writer\n  val bin_writer_lazy_t :\n    'a Bin_prot.Type_class.writer -> 'a lazy_t Bin_prot.Type_class.writer\n  val bin_read_lazy_t :\n    'a Bin_prot.Read.reader -> 'a lazy_t Bin_prot.Read.reader\n  val __bin_read_lazy_t__ :\n    'a Bin_prot.Read.reader -> (Base.int -> 'a lazy_t) Bin_prot.Read.reader\n  val bin_reader_lazy_t :\n    'a Bin_prot.Type_class.reader -> 'a lazy_t Bin_prot.Type_class.reader\n  val bin_lazy_t :\n    'a Bin_prot.Type_class.t -> 'a lazy_t Bin_prot.Type_class.t\n  val compare_lazy_t :\n    ('a -> 'a -> Base.int) -> 'a lazy_t -> 'a lazy_t -> Base.int\n  val hash_fold_lazy_t :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state -> 'a lazy_t -> Ppx_hash_lib.Std.Hash.state\n  val sexp_of_lazy_t :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'a lazy_t -> Ppx_sexp_conv_lib.Sexp.t\n  val lazy_t_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) -> Ppx_sexp_conv_lib.Sexp.t -> 'a lazy_t\n  val typerep_of_lazy_t :\n    'a Typerep_lib.Std.Typerep.t -> 'a lazy_t Typerep_lib.Std.Typerep.t\n  val typename_of_lazy_t :\n    'a Typerep_lib.Std.Typename.t -> 'a lazy_t Typerep_lib.Std.Typename.t\n  val bin_shape_list : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_list :\n    'a Bin_prot.Size.sizer -> 'a sexp_list Bin_prot.Size.sizer\n  val bin_write_list :\n    'a Bin_prot.Write.writer -> 'a sexp_list Bin_prot.Write.writer\n  val bin_writer_list :\n    'a Bin_prot.Type_class.writer -> 'a sexp_list Bin_prot.Type_class.writer\n  val bin_read_list :\n    'a Bin_prot.Read.reader -> 'a sexp_list Bin_prot.Read.reader\n  val __bin_read_list__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_list) Bin_prot.Read.reader\n  val bin_reader_list :\n    'a Bin_prot.Type_class.reader -> 'a sexp_list Bin_prot.Type_class.reader\n  val bin_list :\n    'a Bin_prot.Type_class.t -> 'a sexp_list Bin_prot.Type_class.t\n  val compare_list :\n    ('a -> 'a -> Base.int) -> 'a sexp_list -> 'a sexp_list -> Base.int\n  val equal_list :\n    ('a -> 'a -> sexp_bool) -> 'a sexp_list -> 'a sexp_list -> sexp_bool\n  val hash_fold_list :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state ->\n    'a sexp_list -> Ppx_hash_lib.Std.Hash.state\n  val sexp_of_list :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a sexp_list -> Ppx_sexp_conv_lib.Sexp.t\n  val list_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a sexp_list\n  val typerep_of_list :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_list Typerep_lib.Std.Typerep.t\n  val typename_of_list :\n    'a Typerep_lib.Std.Typename.t -> 'a sexp_list Typerep_lib.Std.Typename.t\n  val bin_shape_nativeint : Bin_prot.Shape.t\n  val bin_size_nativeint : Base.nativeint Bin_prot.Size.sizer\n  val bin_write_nativeint : Base.nativeint Bin_prot.Write.writer\n  val bin_writer_nativeint : Base.nativeint Bin_prot.Type_class.writer\n  val bin_read_nativeint : Base.nativeint Bin_prot.Read.reader\n  val __bin_read_nativeint__ :\n    (Base.int -> Base.nativeint) Bin_prot.Read.reader\n  val bin_reader_nativeint : Base.nativeint Bin_prot.Type_class.reader\n  val bin_nativeint : Base.nativeint Bin_prot.Type_class.t\n  val compare_nativeint : Base.nativeint -> Base.nativeint -> Base.int\n  val equal_nativeint : Base.nativeint -> Base.nativeint -> sexp_bool\n  val hash_fold_nativeint :\n    Ppx_hash_lib.Std.Hash.state ->\n    Base.nativeint -> Ppx_hash_lib.Std.Hash.state\n  val hash_nativeint : Base.nativeint -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_nativeint : Base.nativeint -> Ppx_sexp_conv_lib.Sexp.t\n  val nativeint_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.nativeint\n  val typerep_of_nativeint : Base.nativeint Typerep_lib.Std.Typerep.t\n  val typename_of_nativeint : Base.nativeint Typerep_lib.Std.Typename.t\n  val bin_shape_option : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_option :\n    'a Bin_prot.Size.sizer -> 'a sexp_option Bin_prot.Size.sizer\n  val bin_write_option :\n    'a Bin_prot.Write.writer -> 'a sexp_option Bin_prot.Write.writer\n  val bin_writer_option :\n    'a Bin_prot.Type_class.writer ->\n    'a sexp_option Bin_prot.Type_class.writer\n  val bin_read_option :\n    'a Bin_prot.Read.reader -> 'a sexp_option Bin_prot.Read.reader\n  val __bin_read_option__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_option) Bin_prot.Read.reader\n  val bin_reader_option :\n    'a Bin_prot.Type_class.reader ->\n    'a sexp_option Bin_prot.Type_class.reader\n  val bin_option :\n    'a Bin_prot.Type_class.t -> 'a sexp_option Bin_prot.Type_class.t\n  val compare_option :\n    ('a -> 'a -> Base.int) -> 'a sexp_option -> 'a sexp_option -> Base.int\n  val equal_option :\n    ('a -> 'a -> sexp_bool) -> 'a sexp_option -> 'a sexp_option -> sexp_bool\n  val hash_fold_option :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state ->\n    'a sexp_option -> Ppx_hash_lib.Std.Hash.state\n  val sexp_of_option :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a sexp_option -> Ppx_sexp_conv_lib.Sexp.t\n  val option_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a sexp_option\n  val typerep_of_option :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_option Typerep_lib.Std.Typerep.t\n  val typename_of_option :\n    'a Typerep_lib.Std.Typename.t ->\n    'a sexp_option Typerep_lib.Std.Typename.t\n  val bin_shape_string : Bin_prot.Shape.t\n  val bin_size_string : string Bin_prot.Size.sizer\n  val bin_write_string : string Bin_prot.Write.writer\n  val bin_writer_string : string Bin_prot.Type_class.writer\n  val bin_read_string : string Bin_prot.Read.reader\n  val __bin_read_string__ : (Base.int -> string) Bin_prot.Read.reader\n  val bin_reader_string : string Bin_prot.Type_class.reader\n  val bin_string : string Bin_prot.Type_class.t\n  val compare_string : string -> string -> Base.int\n  val equal_string : string -> string -> sexp_bool\n  val hash_fold_string :\n    Ppx_hash_lib.Std.Hash.state -> string -> Ppx_hash_lib.Std.Hash.state\n  val hash_string : string -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_string : string -> Ppx_sexp_conv_lib.Sexp.t\n  val string_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> string\n  val typerep_of_string : string Typerep_lib.Std.Typerep.t\n  val typename_of_string : string Typerep_lib.Std.Typename.t\n  val bin_shape_bytes : Bin_prot.Shape.t\n  val bin_size_bytes : Base.bytes Bin_prot.Size.sizer\n  val bin_write_bytes : Base.bytes Bin_prot.Write.writer\n  val bin_writer_bytes : Base.bytes Bin_prot.Type_class.writer\n  val bin_read_bytes : Base.bytes Bin_prot.Read.reader\n  val __bin_read_bytes__ : (Base.int -> Base.bytes) Bin_prot.Read.reader\n  val bin_reader_bytes : Base.bytes Bin_prot.Type_class.reader\n  val bin_bytes : Base.bytes Bin_prot.Type_class.t\n  val compare_bytes : Base.bytes -> Base.bytes -> Base.int\n  val equal_bytes : Base.bytes -> Base.bytes -> sexp_bool\n  val sexp_of_bytes : Base.bytes -> Ppx_sexp_conv_lib.Sexp.t\n  val bytes_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.bytes\n  val typerep_of_bytes : Base.bytes Typerep_lib.Std.Typerep.t\n  val typename_of_bytes : Base.bytes Typerep_lib.Std.Typename.t\n  val bin_shape_ref : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_ref : 'a Bin_prot.Size.sizer -> 'a ref Bin_prot.Size.sizer\n  val bin_write_ref :\n    'a Bin_prot.Write.writer -> 'a ref Bin_prot.Write.writer\n  val bin_writer_ref :\n    'a Bin_prot.Type_class.writer -> 'a ref Bin_prot.Type_class.writer\n  val bin_read_ref : 'a Bin_prot.Read.reader -> 'a ref Bin_prot.Read.reader\n  val __bin_read_ref__ :\n    'a Bin_prot.Read.reader -> (Base.int -> 'a ref) Bin_prot.Read.reader\n  val bin_reader_ref :\n    'a Bin_prot.Type_class.reader -> 'a ref Bin_prot.Type_class.reader\n  val bin_ref : 'a Bin_prot.Type_class.t -> 'a ref Bin_prot.Type_class.t\n  val compare_ref : ('a -> 'a -> Base.int) -> 'a ref -> 'a ref -> Base.int\n  val equal_ref : ('a -> 'a -> sexp_bool) -> 'a ref -> 'a ref -> sexp_bool\n  val sexp_of_ref :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'a ref -> Ppx_sexp_conv_lib.Sexp.t\n  val ref_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) -> Ppx_sexp_conv_lib.Sexp.t -> 'a ref\n  val typerep_of_ref :\n    'a Typerep_lib.Std.Typerep.t -> 'a ref Typerep_lib.Std.Typerep.t\n  val typename_of_ref :\n    'a Typerep_lib.Std.Typename.t -> 'a ref Typerep_lib.Std.Typename.t\n  val bin_shape_unit : Bin_prot.Shape.t\n  val bin_size_unit : Base.unit Bin_prot.Size.sizer\n  val bin_write_unit : Base.unit Bin_prot.Write.writer\n  val bin_writer_unit : Base.unit Bin_prot.Type_class.writer\n  val bin_read_unit : Base.unit Bin_prot.Read.reader\n  val __bin_read_unit__ : (Base.int -> Base.unit) Bin_prot.Read.reader\n  val bin_reader_unit : Base.unit Bin_prot.Type_class.reader\n  val bin_unit : Base.unit Bin_prot.Type_class.t\n  val compare_unit : Base.unit -> Base.unit -> Base.int\n  val equal_unit : Base.unit -> Base.unit -> sexp_bool\n  val hash_fold_unit :\n    Ppx_hash_lib.Std.Hash.state -> Base.unit -> Ppx_hash_lib.Std.Hash.state\n  val hash_unit : Base.unit -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_unit : Base.unit -> Ppx_sexp_conv_lib.Sexp.t\n  val unit_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.unit\n  val typerep_of_unit : Base.unit Typerep_lib.Std.Typerep.t\n  val typename_of_unit : Base.unit Typerep_lib.Std.Typename.t\n  type float_array = Base.float sexp_array\n  val bin_shape_float_array : Bin_prot.Shape.t\n  val bin_size_float_array : float_array Bin_prot.Size.sizer\n  val bin_write_float_array : float_array Bin_prot.Write.writer\n  val bin_writer_float_array : float_array Bin_prot.Type_class.writer\n  val bin_read_float_array : float_array Bin_prot.Read.reader\n  val __bin_read_float_array__ :\n    (Base.int -> float_array) Bin_prot.Read.reader\n  val bin_reader_float_array : float_array Bin_prot.Type_class.reader\n  val bin_float_array : float_array Bin_prot.Type_class.t\n  val compare_float_array : float_array -> float_array -> Base.int\n  val sexp_of_float_array : float_array -> Ppx_sexp_conv_lib.Sexp.t\n  val float_array_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> float_array\n  val typerep_of_float_array : float_array Typerep_lib.Std.Typerep.t\n  val typename_of_float_array : float_array Typerep_lib.Std.Typename.t\n  val sexp_of_exn :\n    Exn.t -> Base.Exported_for_specific_uses.Ppx_sexp_conv_lib.Sexp.t\n  type 'a sexp_array = 'a Base.sexp_array\n  val bin_shape_sexp_array : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_sexp_array :\n    'a Bin_prot.Size.sizer -> 'a sexp_array Bin_prot.Size.sizer\n  val bin_write_sexp_array :\n    'a Bin_prot.Write.writer -> 'a sexp_array Bin_prot.Write.writer\n  val bin_writer_sexp_array :\n    'a Bin_prot.Type_class.writer -> 'a sexp_array Bin_prot.Type_class.writer\n  val __bin_read_sexp_array__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_array) Bin_prot.Read.reader\n  val bin_read_sexp_array :\n    'a Bin_prot.Read.reader -> 'a sexp_array Bin_prot.Read.reader\n  val bin_reader_sexp_array :\n    'a Bin_prot.Type_class.reader -> 'a sexp_array Bin_prot.Type_class.reader\n  val bin_sexp_array :\n    'a Bin_prot.Type_class.t -> 'a sexp_array Bin_prot.Type_class.t\n  val compare_sexp_array :\n    ('a -> 'a -> Base.int) -> 'a sexp_array -> 'a sexp_array -> Base.int\n  module Typename_of_sexp_array = Typename_of_sexp_array\n  val typename_of_sexp_array :\n    'a Typerep_lib.Typename.t -> 'a sexp_array Typerep_lib.Typename.t\n  val typerep_of_sexp_array :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_array Typerep_lib.Std.Typerep.t\n  type sexp_bool = bool\n  val bin_shape_sexp_bool : Bin_prot.Shape.t\n  val bin_size_sexp_bool : sexp_bool Bin_prot.Size.sizer\n  val bin_write_sexp_bool : sexp_bool Bin_prot.Write.writer\n  val bin_writer_sexp_bool : sexp_bool Bin_prot.Type_class.writer\n  val __bin_read_sexp_bool__ : (Base.int -> sexp_bool) Bin_prot.Read.reader\n  val bin_read_sexp_bool : sexp_bool Bin_prot.Read.reader\n  val bin_reader_sexp_bool : sexp_bool Bin_prot.Type_class.reader\n  val bin_sexp_bool : sexp_bool Bin_prot.Type_class.t\n  val compare_sexp_bool : sexp_bool -> sexp_bool -> Base.int\n  val hash_fold_sexp_bool :\n    Ppx_hash_lib.Std.Hash.state -> sexp_bool -> Ppx_hash_lib.Std.Hash.state\n  val hash_sexp_bool : sexp_bool -> Ppx_hash_lib.Std.Hash.hash_value\n  module Typename_of_sexp_bool = Typename_of_sexp_bool\n  val typename_of_sexp_bool : sexp_bool Typerep_lib.Typename.t\n  val typerep_of_sexp_bool : sexp_bool Typerep_lib.Std.Typerep.t\n  type 'a sexp_list = 'a list\n  val bin_shape_sexp_list : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_sexp_list :\n    'a Bin_prot.Size.sizer -> 'a sexp_list Bin_prot.Size.sizer\n  val bin_write_sexp_list :\n    'a Bin_prot.Write.writer -> 'a sexp_list Bin_prot.Write.writer\n  val bin_writer_sexp_list :\n    'a Bin_prot.Type_class.writer -> 'a sexp_list Bin_prot.Type_class.writer\n  val __bin_read_sexp_list__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_list) Bin_prot.Read.reader\n  val bin_read_sexp_list :\n    'a Bin_prot.Read.reader -> 'a sexp_list Bin_prot.Read.reader\n  val bin_reader_sexp_list :\n    'a Bin_prot.Type_class.reader -> 'a sexp_list Bin_prot.Type_class.reader\n  val bin_sexp_list :\n    'a Bin_prot.Type_class.t -> 'a sexp_list Bin_prot.Type_class.t\n  val compare_sexp_list :\n    ('a -> 'a -> Base.int) -> 'a sexp_list -> 'a sexp_list -> Base.int\n  val hash_fold_sexp_list :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state ->\n    'a sexp_list -> Ppx_hash_lib.Std.Hash.state\n  module Typename_of_sexp_list = Typename_of_sexp_list\n  val typename_of_sexp_list :\n    'a Typerep_lib.Typename.t -> 'a sexp_list Typerep_lib.Typename.t\n  val typerep_of_sexp_list :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_list Typerep_lib.Std.Typerep.t\n  type 'a sexp_option = 'a option\n  val bin_shape_sexp_option : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_sexp_option :\n    'a Bin_prot.Size.sizer -> 'a sexp_option Bin_prot.Size.sizer\n  val bin_write_sexp_option :\n    'a Bin_prot.Write.writer -> 'a sexp_option Bin_prot.Write.writer\n  val bin_writer_sexp_option :\n    'a Bin_prot.Type_class.writer ->\n    'a sexp_option Bin_prot.Type_class.writer\n  val __bin_read_sexp_option__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_option) Bin_prot.Read.reader\n  val bin_read_sexp_option :\n    'a Bin_prot.Read.reader -> 'a sexp_option Bin_prot.Read.reader\n  val bin_reader_sexp_option :\n    'a Bin_prot.Type_class.reader ->\n    'a sexp_option Bin_prot.Type_class.reader\n  val bin_sexp_option :\n    'a Bin_prot.Type_class.t -> 'a sexp_option Bin_prot.Type_class.t\n  val compare_sexp_option :\n    ('a -> 'a -> Base.int) -> 'a sexp_option -> 'a sexp_option -> Base.int\n  val hash_fold_sexp_option :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state ->\n    'a sexp_option -> Ppx_hash_lib.Std.Hash.state\n  module Typename_of_sexp_option = Typename_of_sexp_option\n  val typename_of_sexp_option :\n    'a Typerep_lib.Typename.t -> 'a sexp_option Typerep_lib.Typename.t\n  val typerep_of_sexp_option :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_option Typerep_lib.Std.Typerep.t\n  type 'a sexp_opaque = 'a\n  val bin_shape_sexp_opaque : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_sexp_opaque : 'a Bin_prot.Size.sizer -> 'a Bin_prot.Size.sizer\n  val bin_write_sexp_opaque :\n    'a Bin_prot.Write.writer -> 'a Bin_prot.Write.writer\n  val bin_writer_sexp_opaque :\n    'a Bin_prot.Type_class.writer -> 'a Bin_prot.Type_class.writer\n  val __bin_read_sexp_opaque__ :\n    'a Bin_prot.Read.reader -> (Base.int -> 'a) Bin_prot.Read.reader\n  val bin_read_sexp_opaque :\n    'a Bin_prot.Read.reader -> 'a Bin_prot.Read.reader\n  val bin_reader_sexp_opaque :\n    'a Bin_prot.Type_class.reader -> 'a Bin_prot.Type_class.reader\n  val bin_sexp_opaque : 'a Bin_prot.Type_class.t -> 'a Bin_prot.Type_class.t\n  val compare_sexp_opaque : ('a -> 'a -> Base.int) -> 'a -> 'a -> Base.int\n  val hash_fold_sexp_opaque :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state\n  module Typename_of_sexp_opaque = Typename_of_sexp_opaque\n  val typename_of_sexp_opaque :\n    'a Typerep_lib.Typename.t -> 'a Typerep_lib.Typename.t\n  val typerep_of_sexp_opaque :\n    'a Typerep_lib.Std.Typerep.t -> 'a Typerep_lib.Std.Typerep.t\n  exception Not_found\n  exception Not_found_s of Ppx_sexp_conv_lib.Sexp.t\n  module Bigstring = Bigstring\n  module Caml = Core.Caml\n  module Command = Command\n  module Condition = Condition\n  module Core_stable = Core_stable\n  module Date = Date\n  module Filename = Core.Filename\n  module Interval = Interval\n  module Interval_intf = Interval_intf\n  module Iobuf = Iobuf\n  module Iobuf_debug = Iobuf_debug\n  module Iobuf_intf = Iobuf_intf\n  module Linux_ext = Linux_ext\n  module Digest = Md5\n  module Mutex = Mutex\n  module Signal = Signal\n  module Sys = Core.Sys\n  module Thread = Thread\n  module Time = Time\n  module Time_common = Time_common\n  module Time_ns = Time_ns\n  module Time_stamp_counter = Time_stamp_counter\n  module Unix = Core.Unix\n  module User_and_group = User_and_group\n  module Version_util = Version_util\n  val sec : Base.float -> Time.Span.t\n  val ( ^/ ) : string -> string -> string\n  module Core_private : sig module Core_zone = Core_private.Core_zone end\nend"}
{"start":{"line":11,"col":0},"end":{"line":11,"col":9},"definition":{"file":"*buffer*","pos":{"line":3,"col":0}}}
{"start":{"line":11,"col":5},"end":{"line":11,"col":9},"type":"sig\n  type t = { value : string; range : Range.t; }\n  val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t\n  val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t\n  val to_yojson : t -> Yojson.Safe.json\n  val of_yojson : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val _ : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val equal : t -> t -> sexp_bool\nend"}
{"start":{"line":12,"col":0},"end":{"line":13,"col":29},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":12,"col":0},"end":{"line":13,"col":29},"type":"data -> data -> sexp_bool"}
{"start":{"line":12,"col":12},"end":{"line":12,"col":16},"type":"sig\n  type t = { value : string; range : Range.t; }\n  val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t\n  val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t\n  val to_yojson : t -> Yojson.Safe.json\n  val of_yojson : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val _ : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val equal : t -> t -> sexp_bool\nend"}
{"start":{"line":12,"col":12},"end":{"line":12,"col":18},"definition":{"file":"*buffer*","pos":{"line":3,"col":0}}}
{"start":{"line":12,"col":12},"end":{"line":12,"col":18},"definition":{"file":"*buffer*","pos":{"line":4,"col":2}}}
{"start":{"line":12,"col":12},"end":{"line":12,"col":18},"type":"type t = { value : string; range : Range.t; }"}
{"start":{"line":12,"col":5},"end":{"line":12,"col":9},"definition":{"file":"*buffer*","pos":{"line":12,"col":0}}}
{"start":{"line":12,"col":5},"end":{"line":12,"col":9},"type":"type data = data"}
{"start":{"line":15,"col":0},"end":{"line":15,"col":31},"type":"type t = data Core.String.Map.t"}
{"start":{"line":15,"col":14},"end":{"line":15,"col":18},"type":"sig\n  module Applicative = Applicative\n  module Avltree = Avltree\n  module Backtrace = Backtrace\n  module Binary_search = Binary_search\n  module Buffer = Base.Buffer\n  module Comparisons = Comparisons\n  module Continue_or_stop = Continue_or_stop\n  module Equal = Equal\n  module Exn = Exn\n  module Expect_test_config = Expect_test_config\n  module Field = Field\n  module Floatable = Floatable\n  module Formatter = Formatter\n  module Hash = Hash\n  module Heap_block = Heap_block\n  module In_channel = In_channel\n  module Int_conversions = Int_conversions\n  module Invariant = Invariant\n  module Monad = Monad\n  module Variant = Variant\n  module Obj_array = Base.Not_exposed_properly.Obj_array\n  module Ordered_collection_common = Ordered_collection_common\n  module Out_channel = Out_channel\n  module Poly = Poly\n  module Polymorphic_compare = Poly\n  module Pretty_printer = Pretty_printer\n  module Random = Base.Random\n  module Sexp_maybe = Sexp_maybe\n  module Staged = Staged\n  module Stringable = Stringable\n  module Uchar = Base.Uchar\n  module Validate = Validate\n  module With_return = With_return\n  module Word_size = Word_size\n  module Array = Core.Array\n  module Binary_searchable = Binary_searchable\n  module Blit = Blit\n  module Bool = Bool\n  module Bytes = Core.Bytes\n  module Char = Core.Char\n  module Comparable = Comparable\n  module Comparator = Comparator\n  module Container = Container\n  module Either = Either\n  module Error = Error\n  module Float = Core.Float\n  module Fn = Fn\n  module Hash_set = Hash_set\n  module Hashtbl = Core.Hashtbl\n  module Hashtbl_intf = Hashtbl_intf\n  module Info = Info\n  module Int = Int\n  module Int_intf = Int_intf\n  module Int32 = Core.Int32\n  module Int63 = Int63\n  module Int64 = Core.Int64\n  module Lazy = Core.Lazy\n  module Linked_queue = Linked_queue\n  module List = Core.List\n  module Maybe_bound = Maybe_bound\n  module Nativeint = Core.Nativeint\n  module Option = Option\n  module Ordering = Ordering\n  module Or_error = Or_error\n  module Printf = Core.Printf\n  module Ref = Ref\n  module Result = Core.Result\n  module Sequence = Sequence\n  module Set = Core.Set\n  module Sexp = Sexp\n  module Sexpable = Sexpable\n  module Sign = Sign\n  module Sign_or_nan = Sign_or_nan\n  module Source_code_position = Source_code_position\n  module String = Core.String\n  module Type_equal = Type_equal\n  module Unit = Unit\n  module Arg = Core.Arg\n  module Bag = Bag\n  module Bigbuffer = Bigbuffer\n  module Bigsubstring = Bigsubstring\n  module Binable = Binable\n  module Bin_prot = Core.Bin_prot\n  module Blang = Blang\n  module Bounded_index = Bounded_index\n  module Bounded_int_table = Bounded_int_table\n  module Bus = Bus\n  module Byte_units = Byte_units\n  module Day_of_week = Day_of_week\n  module Debug = Debug\n  module Deque = Deque\n  module Deriving_hash = Deriving_hash\n  module Doubly_linked = Doubly_linked\n  module Ephemeron = Core.Ephemeron\n  module Fdeque = Fdeque\n  module Flags = Flags\n  module Float_with_finite_only_serialization =\n    Float_with_finite_only_serialization\n  module Fqueue = Fqueue\n  module Gc = Core.Gc\n  module Hash_queue = Hash_queue\n  module Hashable = Hashable\n  module Heap = Heap\n  module Hexdump = Hexdump\n  module Hexdump_intf = Hexdump_intf\n  module Host_and_port = Host_and_port\n  module Identifiable = Identifiable\n  module Immediate_option = Immediate_option\n  module Immediate_option_intf = Immediate_option_intf\n  module Interfaces = Interfaces\n  module Linked_stack = Linked_stack\n  module Map = Core.Map\n  module Md5 = Md5\n  module Memo = Memo\n  module Month = Month\n  module No_polymorphic_compare = No_polymorphic_compare\n  module Nothing = Nothing\n  module Only_in_test = Only_in_test\n  module Option_array = Option_array\n  module Optional_syntax = Optional_syntax\n  module Percent = Percent\n  module Perms = Perms\n  module Pid = Pid\n  module Pool = Pool\n  module Pool_intf = Pool_intf\n  module Popcount = Base__Popcount\n  module Printexc = Core.Printexc\n  module Queue = Core.Queue\n  module Quickcheck = Quickcheck\n  module Quickcheck_intf = Quickcheck_intf\n  module Quickcheckable = Quickcheckable\n  module Robustly_comparable = Robustly_comparable\n  module Set_once = Set_once\n  module Splittable_random = Splittable_random\n  module Stable_comparable = Stable_comparable\n  module Stable_unit_test = Stable_unit_test\n  module Stack = Core.Stack\n  module String_id = String_id\n  module Substring = Substring\n  module Substring_intf = Substring_intf\n  module Timing_wheel_ns = Timing_wheel_ns\n  module Tuple = Tuple\n  module Tuple_type = Tuple_type\n  module Tuple2 = Tuple2\n  module Tuple3 = Tuple3\n  module Type_immediacy = Type_immediacy\n  module Uniform_array = Uniform_array\n  module Union_find = Union_find\n  module Unique_id = Unique_id\n  module Unit_of_time = Unit_of_time\n  module Univ = Univ\n  module Univ_map = Univ_map\n  module Validated = Validated\n  module Weak = Weak\n  module type Unique_id = Unique_id\n  module type T = sig type t end\n  module type T1 = sig type 'a t end\n  module type T2 = sig type ('a, 'b) t end\n  module type T3 = sig type ('a, 'b, 'c) t end\n  module type T_bin =\n    sig\n      type t\n      val bin_size_t : t Bin_prot.Size.sizer\n      val bin_write_t : t Bin_prot.Write.writer\n      val bin_read_t : t Bin_prot.Read.reader\n      val __bin_read_t__ : (int -> t) Bin_prot.Read.reader\n      val bin_shape_t : Bin_prot.Shape.t\n      val bin_writer_t : t Bin_prot.Type_class.writer\n      val bin_reader_t : t Bin_prot.Type_class.reader\n      val bin_t : t Bin_prot.Type_class.t\n    end\n  type 'a _maybe_bound =\n    'a Maybe_bound.t =\n      Incl of 'a\n    | Excl of 'a\n    | Unbounded\n  val does_raise : (unit -> 'a) -> sexp_bool\n  val am_running_inline_test : sexp_bool\n  val am_running_test : sexp_bool\n  external raise : exn -> 'a = \"%reraise\"\n  external raise_notrace : exn -> 'a = \"%raise_notrace\"\n  val invalid_arg : string -> 'a\n  val failwith : string -> 'a\n  exception Exit\n  external ( = ) : 'a -> 'a -> sexp_bool = \"%equal\"\n  external ( <> ) : 'a -> 'a -> sexp_bool = \"%notequal\"\n  external ( < ) : 'a -> 'a -> sexp_bool = \"%lessthan\"\n  external ( > ) : 'a -> 'a -> sexp_bool = \"%greaterthan\"\n  external ( <= ) : 'a -> 'a -> sexp_bool = \"%lessequal\"\n  external ( >= ) : 'a -> 'a -> sexp_bool = \"%greaterequal\"\n  external compare : 'a -> 'a -> int = \"%compare\"\n  val min : 'a -> 'a -> 'a\n  val max : 'a -> 'a -> 'a\n  external ( == ) : 'a -> 'a -> sexp_bool = \"%eq\"\n  external ( != ) : 'a -> 'a -> sexp_bool = \"%noteq\"\n  external not : sexp_bool -> sexp_bool = \"%boolnot\"\n  external ( && ) : sexp_bool -> sexp_bool -> sexp_bool = \"%sequand\"\n  external ( & ) : sexp_bool -> sexp_bool -> sexp_bool = \"%sequand\"\n  external ( || ) : sexp_bool -> sexp_bool -> sexp_bool = \"%sequor\"\n  external ( or ) : sexp_bool -> sexp_bool -> sexp_bool = \"%sequor\"\n  external __LOC__ : string = \"%loc_LOC\"\n  external __FILE__ : string = \"%loc_FILE\"\n  external __LINE__ : int = \"%loc_LINE\"\n  external __MODULE__ : string = \"%loc_MODULE\"\n  external __POS__ : string * int * int * int = \"%loc_POS\"\n  external __LOC_OF__ : 'a -> string * 'a = \"%loc_LOC\"\n  external __LINE_OF__ : 'a -> int * 'a = \"%loc_LINE\"\n  external __POS_OF__ : 'a -> (string * int * int * int) * 'a = \"%loc_POS\"\n  external ( |> ) : 'a -> ('a -> 'b) -> 'b = \"%revapply\"\n  external ( @@ ) : ('a -> 'b) -> 'a -> 'b = \"%apply\"\n  external ( ~- ) : int -> int = \"%negint\"\n  external ( ~+ ) : int -> int = \"%identity\"\n  external succ : int -> int = \"%succint\"\n  external pred : int -> int = \"%predint\"\n  external ( + ) : int -> int -> int = \"%addint\"\n  external ( - ) : int -> int -> int = \"%subint\"\n  external ( * ) : int -> int -> int = \"%mulint\"\n  external ( / ) : int -> int -> int = \"%divint\"\n  external ( mod ) : int -> int -> int = \"%modint\"\n  val abs : int -> int\n  val max_int : int\n  val min_int : int\n  external ( land ) : int -> int -> int = \"%andint\"\n  external ( lor ) : int -> int -> int = \"%orint\"\n  external ( lxor ) : int -> int -> int = \"%xorint\"\n  val lnot : int -> int\n  external ( lsl ) : int -> int -> int = \"%lslint\"\n  external ( lsr ) : int -> int -> int = \"%lsrint\"\n  external ( asr ) : int -> int -> int = \"%asrint\"\n  external ( ~-. ) : float -> float = \"%negfloat\"\n  external ( ~+. ) : float -> float = \"%identity\"\n  external ( +. ) : float -> float -> float = \"%addfloat\"\n  external ( -. ) : float -> float -> float = \"%subfloat\"\n  external ( *. ) : float -> float -> float = \"%mulfloat\"\n  external ( /. ) : float -> float -> float = \"%divfloat\"\n  external ( ** ) : float -> float -> float = \"caml_power_float\" \"pow\"\n    [@@unboxed] [@@noalloc]\n  external sqrt : float -> float = \"caml_sqrt_float\" \"sqrt\" [@@unboxed]\n    [@@noalloc]\n  external exp : float -> float = \"caml_exp_float\" \"exp\" [@@unboxed]\n    [@@noalloc]\n  external log : float -> float = \"caml_log_float\" \"log\" [@@unboxed]\n    [@@noalloc]\n  external log10 : float -> float = \"caml_log10_float\" \"log10\" [@@unboxed]\n    [@@noalloc]\n  external expm1 : float -> float = \"caml_expm1_float\" \"caml_expm1\"\n    [@@unboxed] [@@noalloc]\n  external log1p : float -> float = \"caml_log1p_float\" \"caml_log1p\"\n    [@@unboxed] [@@noalloc]\n  external cos : float -> float = \"caml_cos_float\" \"cos\" [@@unboxed]\n    [@@noalloc]\n  external sin : float -> float = \"caml_sin_float\" \"sin\" [@@unboxed]\n    [@@noalloc]\n  external tan : float -> float = \"caml_tan_float\" \"tan\" [@@unboxed]\n    [@@noalloc]\n  external acos : float -> float = \"caml_acos_float\" \"acos\" [@@unboxed]\n    [@@noalloc]\n  external asin : float -> float = \"caml_asin_float\" \"asin\" [@@unboxed]\n    [@@noalloc]\n  external atan : float -> float = \"caml_atan_float\" \"atan\" [@@unboxed]\n    [@@noalloc]\n  external atan2 : float -> float -> float = \"caml_atan2_float\" \"atan2\"\n    [@@unboxed] [@@noalloc]\n  external hypot : float -> float -> float = \"caml_hypot_float\" \"caml_hypot\"\n    [@@unboxed] [@@noalloc]\n  external cosh : float -> float = \"caml_cosh_float\" \"cosh\" [@@unboxed]\n    [@@noalloc]\n  external sinh : float -> float = \"caml_sinh_float\" \"sinh\" [@@unboxed]\n    [@@noalloc]\n  external tanh : float -> float = \"caml_tanh_float\" \"tanh\" [@@unboxed]\n    [@@noalloc]\n  external ceil : float -> float = \"caml_ceil_float\" \"ceil\" [@@unboxed]\n    [@@noalloc]\n  external floor : float -> float = \"caml_floor_float\" \"floor\" [@@unboxed]\n    [@@noalloc]\n  external abs_float : float -> float = \"%absfloat\"\n  external copysign : float -> float -> float = \"caml_copysign_float\"\n    \"caml_copysign\" [@@unboxed] [@@noalloc]\n  external mod_float : float -> float -> float = \"caml_fmod_float\" \"fmod\"\n    [@@unboxed] [@@noalloc]\n  external frexp : float -> float * int = \"caml_frexp_float\"\n  external ldexp :\n    (float [@unboxed]) -> (int [@untagged]) -> (float [@unboxed])\n    = \"caml_ldexp_float\" \"caml_ldexp_float_unboxed\" [@@noalloc]\n  external modf : float -> float * float = \"caml_modf_float\"\n  external float : int -> float = \"%floatofint\"\n  external float_of_int : int -> float = \"%floatofint\"\n  external truncate : float -> int = \"%intoffloat\"\n  external int_of_float : float -> int = \"%intoffloat\"\n  val infinity : float\n  val neg_infinity : float\n  val nan : float\n  val max_float : float\n  val min_float : float\n  val epsilon_float : float\n  type fpclass =\n    Pervasives.fpclass =\n      FP_normal\n    | FP_subnormal\n    | FP_zero\n    | FP_infinite\n    | FP_nan\n  external classify_float : (float [@unboxed]) -> fpclass\n    = \"caml_classify_float\" \"caml_classify_float_unboxed\" [@@noalloc]\n  val ( ^ ) : string -> string -> string\n  external int_of_char : char -> int = \"%identity\"\n  val char_of_int : int -> char\n  external ignore : 'a -> unit = \"%ignore\"\n  val string_of_bool : sexp_bool -> string\n  val bool_of_string : string -> sexp_bool\n  val string_of_int : int -> string\n  external int_of_string : string -> int = \"caml_int_of_string\"\n  val string_of_float : float -> string\n  external float_of_string : string -> float = \"caml_float_of_string\"\n  external fst : 'a * 'b -> 'a = \"%field0\"\n  external snd : 'a * 'b -> 'b = \"%field1\"\n  type in_channel = Pervasives.in_channel\n  type out_channel = Pervasives.out_channel\n  val stdin : Pervasives.in_channel\n  val stdout : Pervasives.out_channel\n  val stderr : Pervasives.out_channel\n  val print_char : char -> unit\n  val print_string : string -> unit\n  val print_bytes : string -> unit\n  val print_int : int -> unit\n  val print_float : float -> unit\n  val print_endline : string -> unit\n  val print_newline : unit -> unit\n  val prerr_char : char -> unit\n  val prerr_string : string -> unit\n  val prerr_bytes : string -> unit\n  val prerr_int : int -> unit\n  val prerr_float : float -> unit\n  val prerr_endline : string -> unit\n  val prerr_newline : unit -> unit\n  val read_line : unit -> string\n  val read_int : unit -> int\n  val read_float : unit -> float\n  type open_flag =\n    Pervasives.open_flag =\n      Open_rdonly\n    | Open_wronly\n    | Open_append\n    | Open_creat\n    | Open_trunc\n    | Open_excl\n    | Open_binary\n    | Open_text\n    | Open_nonblock\n  val open_out : string -> Pervasives.out_channel\n  val open_out_bin : string -> Pervasives.out_channel\n  val open_out_gen :\n    Pervasives.open_flag sexp_list -> int -> string -> Pervasives.out_channel\n  val flush : Pervasives.out_channel -> unit\n  val flush_all : unit -> unit\n  val output_char : Pervasives.out_channel -> char -> unit\n  val output_string : Pervasives.out_channel -> string -> unit\n  val output_bytes : Pervasives.out_channel -> string -> unit\n  val output : Pervasives.out_channel -> string -> int -> int -> unit\n  val output_substring :\n    Pervasives.out_channel -> string -> int -> int -> unit\n  val output_byte : Pervasives.out_channel -> int -> unit\n  val output_binary_int : Pervasives.out_channel -> int -> unit\n  val output_value : Pervasives.out_channel -> 'a -> unit\n  val seek_out : Pervasives.out_channel -> int -> unit\n  val pos_out : Pervasives.out_channel -> int\n  val out_channel_length : Pervasives.out_channel -> int\n  val close_out : Pervasives.out_channel -> unit\n  val close_out_noerr : Pervasives.out_channel -> unit\n  val set_binary_mode_out : Pervasives.out_channel -> sexp_bool -> unit\n  val open_in : string -> Pervasives.in_channel\n  val open_in_bin : string -> Pervasives.in_channel\n  val open_in_gen :\n    Pervasives.open_flag sexp_list -> int -> string -> Pervasives.in_channel\n  val input_char : Pervasives.in_channel -> char\n  val input_line : Pervasives.in_channel -> string\n  val input : Pervasives.in_channel -> string -> int -> int -> int\n  val really_input : Pervasives.in_channel -> string -> int -> int -> unit\n  val really_input_string : Pervasives.in_channel -> int -> string\n  val input_byte : Pervasives.in_channel -> int\n  val input_binary_int : Pervasives.in_channel -> int\n  val input_value : Pervasives.in_channel -> 'a\n  val seek_in : Pervasives.in_channel -> int -> unit\n  val pos_in : Pervasives.in_channel -> int\n  val in_channel_length : Pervasives.in_channel -> int\n  val close_in : Pervasives.in_channel -> unit\n  val close_in_noerr : Pervasives.in_channel -> unit\n  val set_binary_mode_in : Pervasives.in_channel -> sexp_bool -> unit\n  module LargeFile = Core_kernel__Core_pervasives.LargeFile\n  type 'a ref = 'a Pervasives.ref = { mutable contents : 'a; }\n  external ref : 'a -> 'a ref = \"%makemutable\"\n  external ( ! ) : 'a ref -> 'a = \"%field0\"\n  external ( := ) : 'a ref -> 'a -> unit = \"%setfield0\"\n  external incr : int ref -> unit = \"%incr\"\n  external decr : int ref -> unit = \"%decr\"\n  type ('a, 'b) result = ('a, 'b) Pervasives.result = Ok of 'a | Error of 'b\n  type ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n      ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n  type ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6\n  type ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4\n  val string_of_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string\n  external format_of_string :\n    ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6\n    = \"%identity\"\n  val ( ^^ ) :\n    ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n    ('f, 'b, 'c, 'e, 'g, 'h) format6 -> ('a, 'b, 'c, 'd, 'g, 'h) format6\n  val exit : int -> 'a\n  val at_exit : (unit -> unit) -> unit\n  val valid_float_lexem : string -> string\n  val unsafe_really_input :\n    Pervasives.in_channel -> string -> int -> int -> unit\n  val do_at_exit : unit -> unit\n  val quickcheck_generator_unit : Base.unit Base_quickcheck__.Generator.t\n  val quickcheck_generator_bool : sexp_bool Base_quickcheck__.Generator.t\n  val quickcheck_generator_char : Base.char Base_quickcheck__.Generator.t\n  val quickcheck_generator_string : string Base_quickcheck__.Generator.t\n  val quickcheck_generator_int : Base.int Base_quickcheck__.Generator.t\n  val quickcheck_generator_int32 : Base.int32 Base_quickcheck__.Generator.t\n  val quickcheck_generator_int64 : Base.int64 Base_quickcheck__.Generator.t\n  val quickcheck_generator_nativeint :\n    Base.nativeint Base_quickcheck__.Generator.t\n  val quickcheck_generator_float : Base.float Base_quickcheck__.Generator.t\n  val quickcheck_observer_unit : Base.unit Base_quickcheck__.Observer.t\n  val quickcheck_observer_bool : sexp_bool Base_quickcheck__.Observer.t\n  val quickcheck_observer_char : Base.char Base_quickcheck__.Observer.t\n  val quickcheck_observer_string : string Base_quickcheck__.Observer.t\n  val quickcheck_observer_int : Base.int Base_quickcheck__.Observer.t\n  val quickcheck_observer_int32 : Base.int32 Base_quickcheck__.Observer.t\n  val quickcheck_observer_int64 : Base.int64 Base_quickcheck__.Observer.t\n  val quickcheck_observer_nativeint :\n    Base.nativeint Base_quickcheck__.Observer.t\n  val quickcheck_observer_float : Base.float Base_quickcheck__.Observer.t\n  val quickcheck_shrinker_unit : Base.unit Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_bool : sexp_bool Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_char : Base.char Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_string : string Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_int : Base.int Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_int32 : Base.int32 Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_int64 : Base.int64 Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_nativeint :\n    Base.nativeint Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_float : Base.float Base_quickcheck__.Shrinker.t\n  val quickcheck_generator_option :\n    'a Base_quickcheck__.Generator.t ->\n    'a sexp_option Base_quickcheck__.Generator.t\n  val quickcheck_generator_list :\n    'a Base_quickcheck__.Generator.t ->\n    'a sexp_list Base_quickcheck__.Generator.t\n  val quickcheck_observer_option :\n    'a Base_quickcheck__.Observer.t ->\n    'a sexp_option Base_quickcheck__.Observer.t\n  val quickcheck_observer_list :\n    'a Base_quickcheck__.Observer.t ->\n    'a sexp_list Base_quickcheck__.Observer.t\n  val quickcheck_shrinker_option :\n    'a Base_quickcheck__.Shrinker.t ->\n    'a sexp_option Base_quickcheck__.Shrinker.t\n  val quickcheck_shrinker_list :\n    'a Base_quickcheck__.Shrinker.t ->\n    'a sexp_list Base_quickcheck__.Shrinker.t\n  val ( |! ) : 'a -> ('a -> 'b) -> 'b\n  type ('f, 's) _either = ('f, 's) Base.Either.t = First of 'f | Second of 's\n  val ( >=. ) : Base.float -> Base.float -> sexp_bool\n  val ( <=. ) : Base.float -> Base.float -> sexp_bool\n  val ( =. ) : Base.float -> Base.float -> sexp_bool\n  val ( >. ) : Base.float -> Base.float -> sexp_bool\n  val ( <. ) : Base.float -> Base.float -> sexp_bool\n  val ( <>. ) : Base.float -> Base.float -> sexp_bool\n  val robustly_compare : Base.float -> Base.float -> int\n  type bigstring = Core.bigstring\n  val sexp_of_bigstring : bigstring -> Ppx_sexp_conv_lib.Sexp.t\n  val bigstring_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> bigstring\n  type mat = Core.mat\n  val sexp_of_mat : mat -> Ppx_sexp_conv_lib.Sexp.t\n  val mat_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> mat\n  type vec = Core.vec\n  val sexp_of_vec : vec -> Ppx_sexp_conv_lib.Sexp.t\n  val vec_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> vec\n  val sexp_of_opaque : 'a -> Ppx_sexp_conv_lib.Sexp.t\n  val opaque_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> 'a\n  val sexp_of_pair :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    ('b -> Ppx_sexp_conv_lib.Sexp.t) -> 'a * 'b -> Ppx_sexp_conv_lib.Sexp.t\n  val pair_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    (Ppx_sexp_conv_lib.Sexp.t -> 'b) -> Ppx_sexp_conv_lib.Sexp.t -> 'a * 'b\n  exception Of_sexp_error of Exn.t * Ppx_sexp_conv_lib.Sexp.t\n  val of_sexp_error : string -> Ppx_sexp_conv_lib.Sexp.t -> 'a\n  val of_sexp_error_exn : Exn.t -> Ppx_sexp_conv_lib.Sexp.t -> 'a\n  module type Applicative = Applicative\n  module type Binable = Binable\n  module type Comparable = Comparable\n  module type Comparable_binable = Comparable_binable\n  module type Floatable = Floatable\n  module type Hashable = Hashable\n  module type Hashable_binable = Hashable_binable\n  module type Identifiable = Identifiable\n  module type Infix_comparators = Infix_comparators\n  module type Intable = Intable\n  module type Monad = Monad\n  module type Quickcheckable = Quickcheckable\n  module type Robustly_comparable = Robustly_comparable\n  module type Sexpable = Sexpable\n  module type Stable = Stable\n  module type Stable_int63able = Stable_int63able\n  module type Stable_without_comparator = Stable_without_comparator\n  module type Stable1 = Stable1\n  module type Stable2 = Stable2\n  module type Stable3 = Stable3\n  module type Stable4 = Stable4\n  module type Stringable = Stringable\n  module type Unit = Unit\n  val ( @ ) : 'a sexp_list -> 'a sexp_list -> 'a sexp_list\n  type never_returns = Nothing.t\n  val sexp_of_never_returns : never_returns -> Ppx_sexp_conv_lib.Sexp.t\n  val never_returns : never_returns -> 'a\n  type _ordering = Ordering.t = Less | Equal | Greater\n  type read = Core.read\n  val bin_shape_read : Bin_prot.Shape.t\n  val bin_size_read : read Bin_prot.Size.sizer\n  val bin_write_read : read Bin_prot.Write.writer\n  val bin_writer_read : read Bin_prot.Type_class.writer\n  val bin_read_read : read Bin_prot.Read.reader\n  val __bin_read_read__ : (Base.int -> read) Bin_prot.Read.reader\n  val bin_reader_read : read Bin_prot.Type_class.reader\n  val bin_read : read Bin_prot.Type_class.t\n  val compare_read : read -> read -> Base.int\n  val hash_fold_read :\n    Ppx_hash_lib.Std.Hash.state -> read -> Ppx_hash_lib.Std.Hash.state\n  val hash_read : read -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_read : read -> Ppx_sexp_conv_lib.Sexp.t\n  val read_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> read\n  type write = Core.write\n  val compare_write : write -> write -> Base.int\n  val hash_fold_write :\n    Ppx_hash_lib.Std.Hash.state -> write -> Ppx_hash_lib.Std.Hash.state\n  val hash_write : write -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_write : write -> Ppx_sexp_conv_lib.Sexp.t\n  val write_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> write\n  type immutable = Core.immutable\n  val bin_shape_immutable : Bin_prot.Shape.t\n  val bin_size_immutable : immutable Bin_prot.Size.sizer\n  val bin_write_immutable : immutable Bin_prot.Write.writer\n  val bin_writer_immutable : immutable Bin_prot.Type_class.writer\n  val bin_read_immutable : immutable Bin_prot.Read.reader\n  val __bin_read_immutable__ : (Base.int -> immutable) Bin_prot.Read.reader\n  val bin_reader_immutable : immutable Bin_prot.Type_class.reader\n  val bin_immutable : immutable Bin_prot.Type_class.t\n  val compare_immutable : immutable -> immutable -> Base.int\n  val hash_fold_immutable :\n    Ppx_hash_lib.Std.Hash.state -> immutable -> Ppx_hash_lib.Std.Hash.state\n  val hash_immutable : immutable -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_immutable : immutable -> Ppx_sexp_conv_lib.Sexp.t\n  val immutable_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> immutable\n  type read_write = Core.read_write\n  val bin_shape_read_write : Bin_prot.Shape.t\n  val bin_size_read_write : read_write Bin_prot.Size.sizer\n  val bin_write_read_write : read_write Bin_prot.Write.writer\n  val bin_writer_read_write : read_write Bin_prot.Type_class.writer\n  val bin_read_read_write : read_write Bin_prot.Read.reader\n  val __bin_read_read_write__ : (Base.int -> read_write) Bin_prot.Read.reader\n  val bin_reader_read_write : read_write Bin_prot.Type_class.reader\n  val bin_read_write : read_write Bin_prot.Type_class.t\n  val compare_read_write : read_write -> read_write -> Base.int\n  val hash_fold_read_write :\n    Ppx_hash_lib.Std.Hash.state -> read_write -> Ppx_hash_lib.Std.Hash.state\n  val hash_read_write : read_write -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_read_write : read_write -> Ppx_sexp_conv_lib.Sexp.t\n  val read_write_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> read_write\n  type 'a perms = 'a Core.perms\n  val bin_shape_perms : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_perms : 'a Bin_prot.Size.sizer -> 'a perms Bin_prot.Size.sizer\n  val bin_write_perms :\n    'a Bin_prot.Write.writer -> 'a perms Bin_prot.Write.writer\n  val bin_writer_perms :\n    'a Bin_prot.Type_class.writer -> 'a perms Bin_prot.Type_class.writer\n  val bin_read_perms :\n    'a Bin_prot.Read.reader -> 'a perms Bin_prot.Read.reader\n  val __bin_read_perms__ :\n    'a Bin_prot.Read.reader -> (Base.int -> 'a perms) Bin_prot.Read.reader\n  val bin_reader_perms :\n    'a Bin_prot.Type_class.reader -> 'a perms Bin_prot.Type_class.reader\n  val bin_perms : 'a Bin_prot.Type_class.t -> 'a perms Bin_prot.Type_class.t\n  val compare_perms :\n    ('a -> 'a -> Base.int) -> 'a perms -> 'a perms -> Base.int\n  val hash_fold_perms :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state -> 'a perms -> Ppx_hash_lib.Std.Hash.state\n  val sexp_of_perms :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'a perms -> Ppx_sexp_conv_lib.Sexp.t\n  val perms_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) -> Ppx_sexp_conv_lib.Sexp.t -> 'a perms\n  type ('ok, 'err) _result = ('ok, 'err) Result.t = Ok of 'ok | Error of 'err\n  val is_ok : ('a, 'b) Result.t -> sexp_bool\n  val is_error : ('a, 'b) Result.t -> sexp_bool\n  type -'a return =\n    'a With_return.return = private {\n    return : 'b. 'a -> 'b;\n  } [@@unboxed]\n  exception Bug of string\n  exception C_malloc_exn of Base.int * Base.int\n  exception Finally of Exn.t * Exn.t\n  val fst3 : 'a * 'b * 'c -> 'a\n  val snd3 : 'a * 'b * 'c -> 'b\n  val trd3 : 'a * 'b * 'c -> 'c\n  val uw : 'a sexp_option -> 'a\n  val ( % ) : int -> int -> int\n  val ( /% ) : int -> int -> int\n  val ( // ) : int -> int -> float\n  val ( ==> ) : sexp_bool -> sexp_bool -> sexp_bool\n  val bprintf :\n    Base__Import0.Caml.Buffer.t ->\n    ('a, Base__Import0.Caml.Buffer.t, unit) format -> 'a\n  val const : 'a -> 'b -> 'a\n  val eprintf : ('a, Stdio.Out_channel.t, Base.unit) format -> 'a\n  val error :\n    ?strict:unit -> string -> 'a -> ('a -> Base__Sexp.t) -> 'b Or_error.t\n  val error_s : Base__Sexp.t -> 'a Or_error.t\n  val failwithf : ('a, unit, string, unit -> 'b) format4 -> 'a\n  val failwithp :\n    ?strict:Base.unit ->\n    Lexing.position -> string -> 'a -> ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'b\n  val failwiths :\n    ?strict:Base.unit ->\n    ?here:Lexing.position ->\n    string -> 'a -> ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'b\n  val force : 'a Base.Lazy.t -> 'a\n  val fprintf :\n    Stdio.Out_channel.t -> ('a, Stdio.Out_channel.t, Base.unit) format -> 'a\n  val ident : 'a -> 'a\n  val invalid_argf : ('a, unit, string, unit -> 'b) format4 -> 'a\n  val ifprintf : 'a -> ('b, 'a, 'c, unit) format4 -> 'b\n  val is_none : 'a sexp_option -> sexp_bool\n  val is_some : 'a sexp_option -> sexp_bool\n  val ksprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b\n  val ok_exn : 'a Or_error.t -> 'a\n  val phys_equal : 'a -> 'a -> sexp_bool\n  val phys_same : 'a -> 'b -> sexp_bool\n  val print_s : ?mach:Base.unit -> Ppx_sexp_conv_lib.Sexp.t -> Base.unit\n  val printf : ('a, Stdio.Out_channel.t, Base.unit) format -> 'a\n  val protect : f:(unit -> 'a) -> finally:(unit -> unit) -> 'a\n  val protectx : f:('a -> 'b) -> 'a -> finally:('a -> unit) -> 'b\n  val raise_s : Base__Sexp.t -> 'a\n  val round : ?dir:[ `Down | `Nearest | `Up | `Zero ] -> Float.t -> Float.t\n  val ( **. ) : Base.float -> Base.float -> Base.float\n  val sprintf : ('a, unit, string) format -> 'a\n  val stage : 'a -> 'a Staged.t\n  val unstage : 'a Staged.t -> 'a\n  val with_return : ('a return -> 'a) -> 'a\n  val with_return_option : ('a return -> unit) -> 'a sexp_option\n  module Typerep = Typerep\n  type tuple0 = Core.tuple0\n  val value_tuple0 : tuple0\n  val typerep_of_function :\n    'a Typerep.t -> 'b Typerep.t -> ('a -> 'b) Typerep.t\n  val typerep_of_tuple0 : tuple0 Typerep.t\n  val typerep_of_tuple2 : 'a Typerep.t -> 'b Typerep.t -> ('a * 'b) Typerep.t\n  val typerep_of_tuple3 :\n    'a Typerep.t -> 'b Typerep.t -> 'c Typerep.t -> ('a * 'b * 'c) Typerep.t\n  val typerep_of_tuple4 :\n    'a Typerep.t ->\n    'b Typerep.t ->\n    'c Typerep.t -> 'd Typerep.t -> ('a * 'b * 'c * 'd) Typerep.t\n  val typerep_of_tuple5 :\n    'a Typerep.t ->\n    'b Typerep.t ->\n    'c Typerep.t ->\n    'd Typerep.t -> 'e Typerep.t -> ('a * 'b * 'c * 'd * 'e) Typerep.t\n  val typename_of_function :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t -> ('a -> 'b) Typerep_lib.Typename.t\n  val typename_of_tuple0 : tuple0 Typerep_lib.Typename.t\n  val typename_of_tuple2 :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t -> ('a * 'b) Typerep_lib.Typename.t\n  val typename_of_tuple3 :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t ->\n    'c Typerep_lib.Typename.t -> ('a * 'b * 'c) Typerep_lib.Typename.t\n  val typename_of_tuple4 :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t ->\n    'c Typerep_lib.Typename.t ->\n    'd Typerep_lib.Typename.t -> ('a * 'b * 'c * 'd) Typerep_lib.Typename.t\n  val typename_of_tuple5 :\n    'a Typerep_lib.Typename.t ->\n    'b Typerep_lib.Typename.t ->\n    'c Typerep_lib.Typename.t ->\n    'd Typerep_lib.Typename.t ->\n    'e Typerep_lib.Typename.t ->\n    ('a * 'b * 'c * 'd * 'e) Typerep_lib.Typename.t\n  val bin_shape_array : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_array :\n    'a Bin_prot.Size.sizer -> 'a sexp_array Bin_prot.Size.sizer\n  val bin_write_array :\n    'a Bin_prot.Write.writer -> 'a sexp_array Bin_prot.Write.writer\n  val bin_writer_array :\n    'a Bin_prot.Type_class.writer -> 'a sexp_array Bin_prot.Type_class.writer\n  val bin_read_array :\n    'a Bin_prot.Read.reader -> 'a sexp_array Bin_prot.Read.reader\n  val __bin_read_array__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_array) Bin_prot.Read.reader\n  val bin_reader_array :\n    'a Bin_prot.Type_class.reader -> 'a sexp_array Bin_prot.Type_class.reader\n  val bin_array :\n    'a Bin_prot.Type_class.t -> 'a sexp_array Bin_prot.Type_class.t\n  val compare_array :\n    ('a -> 'a -> Base.int) -> 'a sexp_array -> 'a sexp_array -> Base.int\n  val equal_array :\n    ('a -> 'a -> sexp_bool) -> 'a sexp_array -> 'a sexp_array -> sexp_bool\n  val sexp_of_array :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a sexp_array -> Ppx_sexp_conv_lib.Sexp.t\n  val array_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a sexp_array\n  val typerep_of_array :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_array Typerep_lib.Std.Typerep.t\n  val typename_of_array :\n    'a Typerep_lib.Std.Typename.t -> 'a sexp_array Typerep_lib.Std.Typename.t\n  val bin_shape_bool : Bin_prot.Shape.t\n  val bin_size_bool : sexp_bool Bin_prot.Size.sizer\n  val bin_write_bool : sexp_bool Bin_prot.Write.writer\n  val bin_writer_bool : sexp_bool Bin_prot.Type_class.writer\n  val bin_read_bool : sexp_bool Bin_prot.Read.reader\n  val __bin_read_bool__ : (Base.int -> sexp_bool) Bin_prot.Read.reader\n  val bin_reader_bool : sexp_bool Bin_prot.Type_class.reader\n  val bin_bool : sexp_bool Bin_prot.Type_class.t\n  val compare_bool : sexp_bool -> sexp_bool -> Base.int\n  val equal_bool : sexp_bool -> sexp_bool -> sexp_bool\n  val hash_fold_bool :\n    Ppx_hash_lib.Std.Hash.state -> sexp_bool -> Ppx_hash_lib.Std.Hash.state\n  val hash_bool : sexp_bool -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_bool : sexp_bool -> Ppx_sexp_conv_lib.Sexp.t\n  val bool_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> sexp_bool\n  val typerep_of_bool : sexp_bool Typerep_lib.Std.Typerep.t\n  val typename_of_bool : sexp_bool Typerep_lib.Std.Typename.t\n  val bin_shape_char : Bin_prot.Shape.t\n  val bin_size_char : Base.char Bin_prot.Size.sizer\n  val bin_write_char : Base.char Bin_prot.Write.writer\n  val bin_writer_char : Base.char Bin_prot.Type_class.writer\n  val bin_read_char : Base.char Bin_prot.Read.reader\n  val __bin_read_char__ : (Base.int -> Base.char) Bin_prot.Read.reader\n  val bin_reader_char : Base.char Bin_prot.Type_class.reader\n  val bin_char : Base.char Bin_prot.Type_class.t\n  val compare_char : Base.char -> Base.char -> Base.int\n  val equal_char : Base.char -> Base.char -> sexp_bool\n  val hash_fold_char :\n    Ppx_hash_lib.Std.Hash.state -> Base.char -> Ppx_hash_lib.Std.Hash.state\n  val hash_char : Base.char -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_char : Base.char -> Ppx_sexp_conv_lib.Sexp.t\n  val char_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.char\n  val typerep_of_char : Base.char Typerep_lib.Std.Typerep.t\n  val typename_of_char : Base.char Typerep_lib.Std.Typename.t\n  val bin_shape_float : Bin_prot.Shape.t\n  val bin_size_float : Base.float Bin_prot.Size.sizer\n  val bin_write_float : Base.float Bin_prot.Write.writer\n  val bin_writer_float : Base.float Bin_prot.Type_class.writer\n  val bin_read_float : Base.float Bin_prot.Read.reader\n  val __bin_read_float__ : (Base.int -> Base.float) Bin_prot.Read.reader\n  val bin_reader_float : Base.float Bin_prot.Type_class.reader\n  val bin_float : Base.float Bin_prot.Type_class.t\n  val compare_float : Base.float -> Base.float -> Base.int\n  val equal_float : Base.float -> Base.float -> sexp_bool\n  val hash_fold_float :\n    Ppx_hash_lib.Std.Hash.state -> Base.float -> Ppx_hash_lib.Std.Hash.state\n  val hash_float : Base.float -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_float : Base.float -> Ppx_sexp_conv_lib.Sexp.t\n  val float_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.float\n  val typerep_of_float : Base.float Typerep_lib.Std.Typerep.t\n  val typename_of_float : Base.float Typerep_lib.Std.Typename.t\n  val bin_shape_int : Bin_prot.Shape.t\n  val bin_size_int : Base.int Bin_prot.Size.sizer\n  val bin_write_int : Base.int Bin_prot.Write.writer\n  val bin_writer_int : Base.int Bin_prot.Type_class.writer\n  val bin_read_int : Base.int Bin_prot.Read.reader\n  val __bin_read_int__ : (Base.int -> Base.int) Bin_prot.Read.reader\n  val bin_reader_int : Base.int Bin_prot.Type_class.reader\n  val bin_int : Base.int Bin_prot.Type_class.t\n  val compare_int : Base.int -> Base.int -> Base.int\n  val equal_int : Base.int -> Base.int -> sexp_bool\n  val hash_fold_int :\n    Ppx_hash_lib.Std.Hash.state -> Base.int -> Ppx_hash_lib.Std.Hash.state\n  val hash_int : Base.int -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_int : Base.int -> Ppx_sexp_conv_lib.Sexp.t\n  val int_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.int\n  val typerep_of_int : Base.int Typerep_lib.Std.Typerep.t\n  val typename_of_int : Base.int Typerep_lib.Std.Typename.t\n  val bin_shape_int32 : Bin_prot.Shape.t\n  val bin_size_int32 : Base.int32 Bin_prot.Size.sizer\n  val bin_write_int32 : Base.int32 Bin_prot.Write.writer\n  val bin_writer_int32 : Base.int32 Bin_prot.Type_class.writer\n  val bin_read_int32 : Base.int32 Bin_prot.Read.reader\n  val __bin_read_int32__ : (Base.int -> Base.int32) Bin_prot.Read.reader\n  val bin_reader_int32 : Base.int32 Bin_prot.Type_class.reader\n  val bin_int32 : Base.int32 Bin_prot.Type_class.t\n  val compare_int32 : Base.int32 -> Base.int32 -> Base.int\n  val equal_int32 : Base.int32 -> Base.int32 -> sexp_bool\n  val hash_fold_int32 :\n    Ppx_hash_lib.Std.Hash.state -> Base.int32 -> Ppx_hash_lib.Std.Hash.state\n  val hash_int32 : Base.int32 -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_int32 : Base.int32 -> Ppx_sexp_conv_lib.Sexp.t\n  val int32_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.int32\n  val typerep_of_int32 : Base.int32 Typerep_lib.Std.Typerep.t\n  val typename_of_int32 : Base.int32 Typerep_lib.Std.Typename.t\n  val bin_shape_int64 : Bin_prot.Shape.t\n  val bin_size_int64 : Base.int64 Bin_prot.Size.sizer\n  val bin_write_int64 : Base.int64 Bin_prot.Write.writer\n  val bin_writer_int64 : Base.int64 Bin_prot.Type_class.writer\n  val bin_read_int64 : Base.int64 Bin_prot.Read.reader\n  val __bin_read_int64__ : (Base.int -> Base.int64) Bin_prot.Read.reader\n  val bin_reader_int64 : Base.int64 Bin_prot.Type_class.reader\n  val bin_int64 : Base.int64 Bin_prot.Type_class.t\n  val compare_int64 : Base.int64 -> Base.int64 -> Base.int\n  val equal_int64 : Base.int64 -> Base.int64 -> sexp_bool\n  val hash_fold_int64 :\n    Ppx_hash_lib.Std.Hash.state -> Base.int64 -> Ppx_hash_lib.Std.Hash.state\n  val hash_int64 : Base.int64 -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_int64 : Base.int64 -> Ppx_sexp_conv_lib.Sexp.t\n  val int64_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.int64\n  val typerep_of_int64 : Base.int64 Typerep_lib.Std.Typerep.t\n  val typename_of_int64 : Base.int64 Typerep_lib.Std.Typename.t\n  val bin_shape_lazy_t : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_lazy_t :\n    'a Bin_prot.Size.sizer -> 'a lazy_t Bin_prot.Size.sizer\n  val bin_write_lazy_t :\n    'a Bin_prot.Write.writer -> 'a lazy_t Bin_prot.Write.writer\n  val bin_writer_lazy_t :\n    'a Bin_prot.Type_class.writer -> 'a lazy_t Bin_prot.Type_class.writer\n  val bin_read_lazy_t :\n    'a Bin_prot.Read.reader -> 'a lazy_t Bin_prot.Read.reader\n  val __bin_read_lazy_t__ :\n    'a Bin_prot.Read.reader -> (Base.int -> 'a lazy_t) Bin_prot.Read.reader\n  val bin_reader_lazy_t :\n    'a Bin_prot.Type_class.reader -> 'a lazy_t Bin_prot.Type_class.reader\n  val bin_lazy_t :\n    'a Bin_prot.Type_class.t -> 'a lazy_t Bin_prot.Type_class.t\n  val compare_lazy_t :\n    ('a -> 'a -> Base.int) -> 'a lazy_t -> 'a lazy_t -> Base.int\n  val hash_fold_lazy_t :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state -> 'a lazy_t -> Ppx_hash_lib.Std.Hash.state\n  val sexp_of_lazy_t :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'a lazy_t -> Ppx_sexp_conv_lib.Sexp.t\n  val lazy_t_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) -> Ppx_sexp_conv_lib.Sexp.t -> 'a lazy_t\n  val typerep_of_lazy_t :\n    'a Typerep_lib.Std.Typerep.t -> 'a lazy_t Typerep_lib.Std.Typerep.t\n  val typename_of_lazy_t :\n    'a Typerep_lib.Std.Typename.t -> 'a lazy_t Typerep_lib.Std.Typename.t\n  val bin_shape_list : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_list :\n    'a Bin_prot.Size.sizer -> 'a sexp_list Bin_prot.Size.sizer\n  val bin_write_list :\n    'a Bin_prot.Write.writer -> 'a sexp_list Bin_prot.Write.writer\n  val bin_writer_list :\n    'a Bin_prot.Type_class.writer -> 'a sexp_list Bin_prot.Type_class.writer\n  val bin_read_list :\n    'a Bin_prot.Read.reader -> 'a sexp_list Bin_prot.Read.reader\n  val __bin_read_list__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_list) Bin_prot.Read.reader\n  val bin_reader_list :\n    'a Bin_prot.Type_class.reader -> 'a sexp_list Bin_prot.Type_class.reader\n  val bin_list :\n    'a Bin_prot.Type_class.t -> 'a sexp_list Bin_prot.Type_class.t\n  val compare_list :\n    ('a -> 'a -> Base.int) -> 'a sexp_list -> 'a sexp_list -> Base.int\n  val equal_list :\n    ('a -> 'a -> sexp_bool) -> 'a sexp_list -> 'a sexp_list -> sexp_bool\n  val hash_fold_list :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state ->\n    'a sexp_list -> Ppx_hash_lib.Std.Hash.state\n  val sexp_of_list :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a sexp_list -> Ppx_sexp_conv_lib.Sexp.t\n  val list_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a sexp_list\n  val typerep_of_list :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_list Typerep_lib.Std.Typerep.t\n  val typename_of_list :\n    'a Typerep_lib.Std.Typename.t -> 'a sexp_list Typerep_lib.Std.Typename.t\n  val bin_shape_nativeint : Bin_prot.Shape.t\n  val bin_size_nativeint : Base.nativeint Bin_prot.Size.sizer\n  val bin_write_nativeint : Base.nativeint Bin_prot.Write.writer\n  val bin_writer_nativeint : Base.nativeint Bin_prot.Type_class.writer\n  val bin_read_nativeint : Base.nativeint Bin_prot.Read.reader\n  val __bin_read_nativeint__ :\n    (Base.int -> Base.nativeint) Bin_prot.Read.reader\n  val bin_reader_nativeint : Base.nativeint Bin_prot.Type_class.reader\n  val bin_nativeint : Base.nativeint Bin_prot.Type_class.t\n  val compare_nativeint : Base.nativeint -> Base.nativeint -> Base.int\n  val equal_nativeint : Base.nativeint -> Base.nativeint -> sexp_bool\n  val hash_fold_nativeint :\n    Ppx_hash_lib.Std.Hash.state ->\n    Base.nativeint -> Ppx_hash_lib.Std.Hash.state\n  val hash_nativeint : Base.nativeint -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_nativeint : Base.nativeint -> Ppx_sexp_conv_lib.Sexp.t\n  val nativeint_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.nativeint\n  val typerep_of_nativeint : Base.nativeint Typerep_lib.Std.Typerep.t\n  val typename_of_nativeint : Base.nativeint Typerep_lib.Std.Typename.t\n  val bin_shape_option : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_option :\n    'a Bin_prot.Size.sizer -> 'a sexp_option Bin_prot.Size.sizer\n  val bin_write_option :\n    'a Bin_prot.Write.writer -> 'a sexp_option Bin_prot.Write.writer\n  val bin_writer_option :\n    'a Bin_prot.Type_class.writer ->\n    'a sexp_option Bin_prot.Type_class.writer\n  val bin_read_option :\n    'a Bin_prot.Read.reader -> 'a sexp_option Bin_prot.Read.reader\n  val __bin_read_option__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_option) Bin_prot.Read.reader\n  val bin_reader_option :\n    'a Bin_prot.Type_class.reader ->\n    'a sexp_option Bin_prot.Type_class.reader\n  val bin_option :\n    'a Bin_prot.Type_class.t -> 'a sexp_option Bin_prot.Type_class.t\n  val compare_option :\n    ('a -> 'a -> Base.int) -> 'a sexp_option -> 'a sexp_option -> Base.int\n  val equal_option :\n    ('a -> 'a -> sexp_bool) -> 'a sexp_option -> 'a sexp_option -> sexp_bool\n  val hash_fold_option :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state ->\n    'a sexp_option -> Ppx_hash_lib.Std.Hash.state\n  val sexp_of_option :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a sexp_option -> Ppx_sexp_conv_lib.Sexp.t\n  val option_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a sexp_option\n  val typerep_of_option :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_option Typerep_lib.Std.Typerep.t\n  val typename_of_option :\n    'a Typerep_lib.Std.Typename.t ->\n    'a sexp_option Typerep_lib.Std.Typename.t\n  val bin_shape_string : Bin_prot.Shape.t\n  val bin_size_string : string Bin_prot.Size.sizer\n  val bin_write_string : string Bin_prot.Write.writer\n  val bin_writer_string : string Bin_prot.Type_class.writer\n  val bin_read_string : string Bin_prot.Read.reader\n  val __bin_read_string__ : (Base.int -> string) Bin_prot.Read.reader\n  val bin_reader_string : string Bin_prot.Type_class.reader\n  val bin_string : string Bin_prot.Type_class.t\n  val compare_string : string -> string -> Base.int\n  val equal_string : string -> string -> sexp_bool\n  val hash_fold_string :\n    Ppx_hash_lib.Std.Hash.state -> string -> Ppx_hash_lib.Std.Hash.state\n  val hash_string : string -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_string : string -> Ppx_sexp_conv_lib.Sexp.t\n  val string_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> string\n  val typerep_of_string : string Typerep_lib.Std.Typerep.t\n  val typename_of_string : string Typerep_lib.Std.Typename.t\n  val bin_shape_bytes : Bin_prot.Shape.t\n  val bin_size_bytes : Base.bytes Bin_prot.Size.sizer\n  val bin_write_bytes : Base.bytes Bin_prot.Write.writer\n  val bin_writer_bytes : Base.bytes Bin_prot.Type_class.writer\n  val bin_read_bytes : Base.bytes Bin_prot.Read.reader\n  val __bin_read_bytes__ : (Base.int -> Base.bytes) Bin_prot.Read.reader\n  val bin_reader_bytes : Base.bytes Bin_prot.Type_class.reader\n  val bin_bytes : Base.bytes Bin_prot.Type_class.t\n  val compare_bytes : Base.bytes -> Base.bytes -> Base.int\n  val equal_bytes : Base.bytes -> Base.bytes -> sexp_bool\n  val sexp_of_bytes : Base.bytes -> Ppx_sexp_conv_lib.Sexp.t\n  val bytes_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.bytes\n  val typerep_of_bytes : Base.bytes Typerep_lib.Std.Typerep.t\n  val typename_of_bytes : Base.bytes Typerep_lib.Std.Typename.t\n  val bin_shape_ref : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_ref : 'a Bin_prot.Size.sizer -> 'a ref Bin_prot.Size.sizer\n  val bin_write_ref :\n    'a Bin_prot.Write.writer -> 'a ref Bin_prot.Write.writer\n  val bin_writer_ref :\n    'a Bin_prot.Type_class.writer -> 'a ref Bin_prot.Type_class.writer\n  val bin_read_ref : 'a Bin_prot.Read.reader -> 'a ref Bin_prot.Read.reader\n  val __bin_read_ref__ :\n    'a Bin_prot.Read.reader -> (Base.int -> 'a ref) Bin_prot.Read.reader\n  val bin_reader_ref :\n    'a Bin_prot.Type_class.reader -> 'a ref Bin_prot.Type_class.reader\n  val bin_ref : 'a Bin_prot.Type_class.t -> 'a ref Bin_prot.Type_class.t\n  val compare_ref : ('a -> 'a -> Base.int) -> 'a ref -> 'a ref -> Base.int\n  val equal_ref : ('a -> 'a -> sexp_bool) -> 'a ref -> 'a ref -> sexp_bool\n  val sexp_of_ref :\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'a ref -> Ppx_sexp_conv_lib.Sexp.t\n  val ref_of_sexp :\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) -> Ppx_sexp_conv_lib.Sexp.t -> 'a ref\n  val typerep_of_ref :\n    'a Typerep_lib.Std.Typerep.t -> 'a ref Typerep_lib.Std.Typerep.t\n  val typename_of_ref :\n    'a Typerep_lib.Std.Typename.t -> 'a ref Typerep_lib.Std.Typename.t\n  val bin_shape_unit : Bin_prot.Shape.t\n  val bin_size_unit : Base.unit Bin_prot.Size.sizer\n  val bin_write_unit : Base.unit Bin_prot.Write.writer\n  val bin_writer_unit : Base.unit Bin_prot.Type_class.writer\n  val bin_read_unit : Base.unit Bin_prot.Read.reader\n  val __bin_read_unit__ : (Base.int -> Base.unit) Bin_prot.Read.reader\n  val bin_reader_unit : Base.unit Bin_prot.Type_class.reader\n  val bin_unit : Base.unit Bin_prot.Type_class.t\n  val compare_unit : Base.unit -> Base.unit -> Base.int\n  val equal_unit : Base.unit -> Base.unit -> sexp_bool\n  val hash_fold_unit :\n    Ppx_hash_lib.Std.Hash.state -> Base.unit -> Ppx_hash_lib.Std.Hash.state\n  val hash_unit : Base.unit -> Ppx_hash_lib.Std.Hash.hash_value\n  val sexp_of_unit : Base.unit -> Ppx_sexp_conv_lib.Sexp.t\n  val unit_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> Base.unit\n  val typerep_of_unit : Base.unit Typerep_lib.Std.Typerep.t\n  val typename_of_unit : Base.unit Typerep_lib.Std.Typename.t\n  type float_array = Base.float sexp_array\n  val bin_shape_float_array : Bin_prot.Shape.t\n  val bin_size_float_array : float_array Bin_prot.Size.sizer\n  val bin_write_float_array : float_array Bin_prot.Write.writer\n  val bin_writer_float_array : float_array Bin_prot.Type_class.writer\n  val bin_read_float_array : float_array Bin_prot.Read.reader\n  val __bin_read_float_array__ :\n    (Base.int -> float_array) Bin_prot.Read.reader\n  val bin_reader_float_array : float_array Bin_prot.Type_class.reader\n  val bin_float_array : float_array Bin_prot.Type_class.t\n  val compare_float_array : float_array -> float_array -> Base.int\n  val sexp_of_float_array : float_array -> Ppx_sexp_conv_lib.Sexp.t\n  val float_array_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> float_array\n  val typerep_of_float_array : float_array Typerep_lib.Std.Typerep.t\n  val typename_of_float_array : float_array Typerep_lib.Std.Typename.t\n  val sexp_of_exn :\n    Exn.t -> Base.Exported_for_specific_uses.Ppx_sexp_conv_lib.Sexp.t\n  type 'a sexp_array = 'a Base.sexp_array\n  val bin_shape_sexp_array : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_sexp_array :\n    'a Bin_prot.Size.sizer -> 'a sexp_array Bin_prot.Size.sizer\n  val bin_write_sexp_array :\n    'a Bin_prot.Write.writer -> 'a sexp_array Bin_prot.Write.writer\n  val bin_writer_sexp_array :\n    'a Bin_prot.Type_class.writer -> 'a sexp_array Bin_prot.Type_class.writer\n  val __bin_read_sexp_array__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_array) Bin_prot.Read.reader\n  val bin_read_sexp_array :\n    'a Bin_prot.Read.reader -> 'a sexp_array Bin_prot.Read.reader\n  val bin_reader_sexp_array :\n    'a Bin_prot.Type_class.reader -> 'a sexp_array Bin_prot.Type_class.reader\n  val bin_sexp_array :\n    'a Bin_prot.Type_class.t -> 'a sexp_array Bin_prot.Type_class.t\n  val compare_sexp_array :\n    ('a -> 'a -> Base.int) -> 'a sexp_array -> 'a sexp_array -> Base.int\n  module Typename_of_sexp_array = Typename_of_sexp_array\n  val typename_of_sexp_array :\n    'a Typerep_lib.Typename.t -> 'a sexp_array Typerep_lib.Typename.t\n  val typerep_of_sexp_array :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_array Typerep_lib.Std.Typerep.t\n  type sexp_bool = bool\n  val bin_shape_sexp_bool : Bin_prot.Shape.t\n  val bin_size_sexp_bool : sexp_bool Bin_prot.Size.sizer\n  val bin_write_sexp_bool : sexp_bool Bin_prot.Write.writer\n  val bin_writer_sexp_bool : sexp_bool Bin_prot.Type_class.writer\n  val __bin_read_sexp_bool__ : (Base.int -> sexp_bool) Bin_prot.Read.reader\n  val bin_read_sexp_bool : sexp_bool Bin_prot.Read.reader\n  val bin_reader_sexp_bool : sexp_bool Bin_prot.Type_class.reader\n  val bin_sexp_bool : sexp_bool Bin_prot.Type_class.t\n  val compare_sexp_bool : sexp_bool -> sexp_bool -> Base.int\n  val hash_fold_sexp_bool :\n    Ppx_hash_lib.Std.Hash.state -> sexp_bool -> Ppx_hash_lib.Std.Hash.state\n  val hash_sexp_bool : sexp_bool -> Ppx_hash_lib.Std.Hash.hash_value\n  module Typename_of_sexp_bool = Typename_of_sexp_bool\n  val typename_of_sexp_bool : sexp_bool Typerep_lib.Typename.t\n  val typerep_of_sexp_bool : sexp_bool Typerep_lib.Std.Typerep.t\n  type 'a sexp_list = 'a list\n  val bin_shape_sexp_list : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_sexp_list :\n    'a Bin_prot.Size.sizer -> 'a sexp_list Bin_prot.Size.sizer\n  val bin_write_sexp_list :\n    'a Bin_prot.Write.writer -> 'a sexp_list Bin_prot.Write.writer\n  val bin_writer_sexp_list :\n    'a Bin_prot.Type_class.writer -> 'a sexp_list Bin_prot.Type_class.writer\n  val __bin_read_sexp_list__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_list) Bin_prot.Read.reader\n  val bin_read_sexp_list :\n    'a Bin_prot.Read.reader -> 'a sexp_list Bin_prot.Read.reader\n  val bin_reader_sexp_list :\n    'a Bin_prot.Type_class.reader -> 'a sexp_list Bin_prot.Type_class.reader\n  val bin_sexp_list :\n    'a Bin_prot.Type_class.t -> 'a sexp_list Bin_prot.Type_class.t\n  val compare_sexp_list :\n    ('a -> 'a -> Base.int) -> 'a sexp_list -> 'a sexp_list -> Base.int\n  val hash_fold_sexp_list :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state ->\n    'a sexp_list -> Ppx_hash_lib.Std.Hash.state\n  module Typename_of_sexp_list = Typename_of_sexp_list\n  val typename_of_sexp_list :\n    'a Typerep_lib.Typename.t -> 'a sexp_list Typerep_lib.Typename.t\n  val typerep_of_sexp_list :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_list Typerep_lib.Std.Typerep.t\n  type 'a sexp_option = 'a option\n  val bin_shape_sexp_option : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_sexp_option :\n    'a Bin_prot.Size.sizer -> 'a sexp_option Bin_prot.Size.sizer\n  val bin_write_sexp_option :\n    'a Bin_prot.Write.writer -> 'a sexp_option Bin_prot.Write.writer\n  val bin_writer_sexp_option :\n    'a Bin_prot.Type_class.writer ->\n    'a sexp_option Bin_prot.Type_class.writer\n  val __bin_read_sexp_option__ :\n    'a Bin_prot.Read.reader ->\n    (Base.int -> 'a sexp_option) Bin_prot.Read.reader\n  val bin_read_sexp_option :\n    'a Bin_prot.Read.reader -> 'a sexp_option Bin_prot.Read.reader\n  val bin_reader_sexp_option :\n    'a Bin_prot.Type_class.reader ->\n    'a sexp_option Bin_prot.Type_class.reader\n  val bin_sexp_option :\n    'a Bin_prot.Type_class.t -> 'a sexp_option Bin_prot.Type_class.t\n  val compare_sexp_option :\n    ('a -> 'a -> Base.int) -> 'a sexp_option -> 'a sexp_option -> Base.int\n  val hash_fold_sexp_option :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state ->\n    'a sexp_option -> Ppx_hash_lib.Std.Hash.state\n  module Typename_of_sexp_option = Typename_of_sexp_option\n  val typename_of_sexp_option :\n    'a Typerep_lib.Typename.t -> 'a sexp_option Typerep_lib.Typename.t\n  val typerep_of_sexp_option :\n    'a Typerep_lib.Std.Typerep.t -> 'a sexp_option Typerep_lib.Std.Typerep.t\n  type 'a sexp_opaque = 'a\n  val bin_shape_sexp_opaque : Bin_prot.Shape.t -> Bin_prot.Shape.t\n  val bin_size_sexp_opaque : 'a Bin_prot.Size.sizer -> 'a Bin_prot.Size.sizer\n  val bin_write_sexp_opaque :\n    'a Bin_prot.Write.writer -> 'a Bin_prot.Write.writer\n  val bin_writer_sexp_opaque :\n    'a Bin_prot.Type_class.writer -> 'a Bin_prot.Type_class.writer\n  val __bin_read_sexp_opaque__ :\n    'a Bin_prot.Read.reader -> (Base.int -> 'a) Bin_prot.Read.reader\n  val bin_read_sexp_opaque :\n    'a Bin_prot.Read.reader -> 'a Bin_prot.Read.reader\n  val bin_reader_sexp_opaque :\n    'a Bin_prot.Type_class.reader -> 'a Bin_prot.Type_class.reader\n  val bin_sexp_opaque : 'a Bin_prot.Type_class.t -> 'a Bin_prot.Type_class.t\n  val compare_sexp_opaque : ('a -> 'a -> Base.int) -> 'a -> 'a -> Base.int\n  val hash_fold_sexp_opaque :\n    (Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state) ->\n    Ppx_hash_lib.Std.Hash.state -> 'a -> Ppx_hash_lib.Std.Hash.state\n  module Typename_of_sexp_opaque = Typename_of_sexp_opaque\n  val typename_of_sexp_opaque :\n    'a Typerep_lib.Typename.t -> 'a Typerep_lib.Typename.t\n  val typerep_of_sexp_opaque :\n    'a Typerep_lib.Std.Typerep.t -> 'a Typerep_lib.Std.Typerep.t\n  exception Not_found\n  exception Not_found_s of Ppx_sexp_conv_lib.Sexp.t\n  module Bigstring = Bigstring\n  module Caml = Core.Caml\n  module Command = Command\n  module Condition = Condition\n  module Core_stable = Core_stable\n  module Date = Date\n  module Filename = Core.Filename\n  module Interval = Interval\n  module Interval_intf = Interval_intf\n  module Iobuf = Iobuf\n  module Iobuf_debug = Iobuf_debug\n  module Iobuf_intf = Iobuf_intf\n  module Linux_ext = Linux_ext\n  module Digest = Md5\n  module Mutex = Mutex\n  module Signal = Signal\n  module Sys = Core.Sys\n  module Thread = Thread\n  module Time = Time\n  module Time_common = Time_common\n  module Time_ns = Time_ns\n  module Time_stamp_counter = Time_stamp_counter\n  module Unix = Core.Unix\n  module User_and_group = User_and_group\n  module Version_util = Version_util\n  val sec : Base.float -> Time.Span.t\n  val ( ^/ ) : string -> string -> string\n  module Core_private : sig module Core_zone = Core_private.Core_zone end\nend"}
{"start":{"line":15,"col":14},"end":{"line":15,"col":25},"type":"(module Core.String)"}
{"start":{"line":15,"col":14},"end":{"line":15,"col":29},"type":"(module Core.String.Map)"}
{"start":{"line":15,"col":14},"end":{"line":15,"col":31},"type":"type 'a t = (string, 'a, Base.String.comparator_witness) Base.Map.t"}
{"start":{"line":15,"col":5},"end":{"line":15,"col":6},"type":"type t = data Core.String.Map.t"}
{"start":{"line":15,"col":9},"end":{"line":15,"col":13},"definition":{"file":"*buffer*","pos":{"line":12,"col":0}}}
{"start":{"line":15,"col":9},"end":{"line":15,"col":13},"type":"type data = data"}
{"start":{"line":15,"col":9},"end":{"line":15,"col":31},"definition":{"file":"/Users/rvt/.opam/default/lib/core/core.ml","pos":{"line":1,"col":0}}}
{"start":{"line":17,"col":11},"end":{"line":17,"col":13},"type":"unit"}
{"start":{"line":17,"col":16},"end":{"line":17,"col":17},"definition":{"file":"*buffer*","pos":{"line":15,"col":0}}}
{"start":{"line":17,"col":16},"end":{"line":17,"col":17},"type":"type t = data Core.String.Map.t"}
{"start":{"line":17,"col":4},"end":{"line":17,"col":10},"type":"unit -> t"}
{"start":{"line":18,"col":2},"end":{"line":18,"col":12},"type":"(module Core.String.Map)"}
{"start":{"line":18,"col":2},"end":{"line":18,"col":18},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":18,"col":2},"end":{"line":18,"col":18},"type":"'a Core.String.Map.t"}
{"start":{"line":18,"col":2},"end":{"line":18,"col":18},"type":"t"}
{"start":{"line":18,"col":2},"end":{"line":18,"col":8},"type":"(module Core.String)"}
{"start":{"line":20,"col":10},"end":{"line":20,"col":13},"type":"t"}
{"start":{"line":20,"col":16},"end":{"line":20,"col":17},"definition":{"file":"*buffer*","pos":{"line":15,"col":0}}}
{"start":{"line":20,"col":16},"end":{"line":20,"col":17},"type":"type t = data Core.String.Map.t"}
{"start":{"line":20,"col":21},"end":{"line":20,"col":27},"type":"type string"}
{"start":{"line":20,"col":28},"end":{"line":20,"col":32},"type":"type 'a list = [] | (::) of 'a * 'a sexp_list"}
{"start":{"line":20,"col":4},"end":{"line":20,"col":8},"type":"t -> string sexp_list"}
{"start":{"line":21,"col":11},"end":{"line":21,"col":14},"definition":{"file":"*buffer*","pos":{"line":20,"col":10}}}
{"start":{"line":21,"col":11},"end":{"line":21,"col":14},"type":"t"}
{"start":{"line":21,"col":2},"end":{"line":21,"col":10},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1318,"col":6}}}
{"start":{"line":21,"col":2},"end":{"line":21,"col":10},"type":"('k, 'a, 'b) Base.Map.t -> 'k sexp_list"}
{"start":{"line":21,"col":2},"end":{"line":21,"col":14},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":21,"col":2},"end":{"line":21,"col":14},"type":"string sexp_list"}
{"start":{"line":21,"col":2},"end":{"line":21,"col":5},"type":"(module Core.Map)"}
{"start":{"line":23,"col":10},"end":{"line":23,"col":15},"type":"Range.t"}
{"start":{"line":23,"col":10},"end":{"line":23,"col":31},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":23,"col":10},"end":{"line":23,"col":31},"type":"Range.t sexp_option"}
{"start":{"line":23,"col":18},"end":{"line":23,"col":23},"type":"(module Range)"}
{"start":{"line":23,"col":18},"end":{"line":23,"col":31},"definition":{"file":"/Users/rvt/official-comby/lib/match/range.ml","pos":{"line":1,"col":0}}}
{"start":{"line":23,"col":18},"end":{"line":23,"col":31},"definition":{"file":"/Users/rvt/official-comby/lib/match/range.ml","pos":{"line":7,"col":4}}}
{"start":{"line":23,"col":18},"end":{"line":23,"col":31},"type":"Range.t"}
{"start":{"line":23,"col":34},"end":{"line":23,"col":37},"type":"t"}
{"start":{"line":23,"col":40},"end":{"line":23,"col":41},"definition":{"file":"*buffer*","pos":{"line":15,"col":0}}}
{"start":{"line":23,"col":40},"end":{"line":23,"col":41},"type":"type t = data Core.String.Map.t"}
{"start":{"line":23,"col":44},"end":{"line":23,"col":47},"type":"string"}
{"start":{"line":23,"col":4},"end":{"line":23,"col":7},"type":"?range:Range.t -> t -> string -> string -> t"}
{"start":{"line":23,"col":50},"end":{"line":23,"col":56},"type":"type string"}
{"start":{"line":23,"col":59},"end":{"line":23,"col":64},"definition":{"file":"*buffer*","pos":{"line":4,"col":2}}}
{"start":{"line":23,"col":59},"end":{"line":23,"col":64},"type":"string"}
{"start":{"line":23,"col":67},"end":{"line":23,"col":73},"type":"type string"}
{"start":{"line":23,"col":77},"end":{"line":23,"col":78},"definition":{"file":"*buffer*","pos":{"line":15,"col":0}}}
{"start":{"line":23,"col":77},"end":{"line":23,"col":78},"type":"type t = data Core.String.Map.t"}
{"start":{"line":23,"col":8},"end":{"line":27,"col":18},"type":"t -> string -> string -> t"}
{"start":{"line":24,"col":10},"end":{"line":24,"col":13},"definition":{"file":"*buffer*","pos":{"line":23,"col":34}}}
{"start":{"line":24,"col":10},"end":{"line":24,"col":13},"type":"t"}
{"start":{"line":24,"col":19},"end":{"line":24,"col":22},"definition":{"file":"*buffer*","pos":{"line":23,"col":44}}}
{"start":{"line":24,"col":19},"end":{"line":24,"col":22},"type":"string"}
{"start":{"line":24,"col":29},"end":{"line":24,"col":45},"type":"data"}
{"start":{"line":24,"col":2},"end":{"line":24,"col":45},"type":"(string, data, Base.String.comparator_witness) Base.Map.t\nBase.Map.Or_duplicate.t"}
{"start":{"line":24,"col":2},"end":{"line":24,"col":5},"type":"(module Core.Map)"}
{"start":{"line":24,"col":2},"end":{"line":24,"col":9},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1257,"col":6}}}
{"start":{"line":24,"col":2},"end":{"line":24,"col":9},"type":"('k, 'v, 'cmp) Base.Map.t ->\nkey:'k -> data:'v -> ('k, 'v, 'cmp) Base.Map.t Base.Map.Or_duplicate.t"}
{"start":{"line":24,"col":2},"end":{"line":27,"col":18},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":24,"col":2},"end":{"line":27,"col":18},"type":"t"}
{"start":{"line":24,"col":31},"end":{"line":24,"col":36},"definition":{"file":"*buffer*","pos":{"line":23,"col":59}}}
{"start":{"line":24,"col":31},"end":{"line":24,"col":36},"type":"string"}
{"start":{"line":24,"col":38},"end":{"line":24,"col":43},"definition":{"file":"*buffer*","pos":{"line":23,"col":10}}}
{"start":{"line":24,"col":38},"end":{"line":24,"col":43},"type":"Range.t"}
{"start":{"line":25,"col":2},"end":{"line":25,"col":4},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":40,"col":0}}}
{"start":{"line":25,"col":2},"end":{"line":25,"col":4},"type":"(string, data, Base.String.comparator_witness) Base.Map.t\nBase.Map.Or_duplicate.t ->\n((string, data, Base.String.comparator_witness) Base.Map.t\n Base.Map.Or_duplicate.t -> t) ->\nt"}
{"start":{"line":25,"col":5},"end":{"line":27,"col":18},"type":"(string, data, Base.String.comparator_witness) Base.Map.t\nBase.Map.Or_duplicate.t -> t"}
{"start":{"line":26,"col":18},"end":{"line":26,"col":21},"definition":{"file":"*buffer*","pos":{"line":23,"col":34}}}
{"start":{"line":26,"col":18},"end":{"line":26,"col":21},"type":"t"}
{"start":{"line":26,"col":4},"end":{"line":26,"col":14},"type":"(string, data, Base.String.comparator_witness) Base.Map.t\nBase.Map.Or_duplicate.t"}
{"start":{"line":27,"col":15},"end":{"line":27,"col":18},"definition":{"file":"*buffer*","pos":{"line":27,"col":8}}}
{"start":{"line":27,"col":15},"end":{"line":27,"col":18},"type":"(string, data, Base.String.comparator_witness) Base.Map.t"}
{"start":{"line":27,"col":15},"end":{"line":27,"col":18},"type":"t"}
{"start":{"line":27,"col":4},"end":{"line":27,"col":11},"type":"(string, data, Base.String.comparator_witness) Base.Map.t\nBase.Map.Or_duplicate.t"}
{"start":{"line":27,"col":8},"end":{"line":27,"col":11},"type":"(string, data, Base.String.comparator_witness) Base.Map.t"}
{"start":{"line":29,"col":12},"end":{"line":29,"col":15},"type":"t"}
{"start":{"line":29,"col":18},"end":{"line":29,"col":19},"definition":{"file":"*buffer*","pos":{"line":15,"col":0}}}
{"start":{"line":29,"col":18},"end":{"line":29,"col":19},"type":"type t = data Core.String.Map.t"}
{"start":{"line":29,"col":22},"end":{"line":29,"col":25},"type":"string"}
{"start":{"line":29,"col":28},"end":{"line":29,"col":34},"type":"type string"}
{"start":{"line":29,"col":38},"end":{"line":29,"col":44},"type":"type string"}
{"start":{"line":29,"col":45},"end":{"line":29,"col":51},"type":"type 'a option = None | Some of 'a"}
{"start":{"line":29,"col":4},"end":{"line":29,"col":10},"type":"t -> string -> string sexp_option"}
{"start":{"line":3,"col":0},"end":{"line":9,"col":3},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":3,"col":0},"end":{"line":9,"col":3},"type":"sig\n  type t = { value : string; range : Range.t; }\n  val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t\n  val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t\n  val to_yojson : t -> Yojson.Safe.json\n  val of_yojson : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val _ : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val equal : t -> t -> sexp_bool\nend"}
{"start":{"line":3,"col":14},"end":{"line":9,"col":3},"type":"sig\n  type t = { value : string; range : Range.t; }\n  val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t\n  val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t\n  val to_yojson : t -> Yojson.Safe.json\n  val of_yojson : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val _ : t -> Yojson.Safe.json\n  val _ : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val equal : t -> t -> sexp_bool\nend"}
{"start":{"line":3,"col":7},"end":{"line":3,"col":11},"type":"sig\n  type t = { value : string; range : Range.t; }\n  val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t\n  val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t\n  val to_yojson : t -> Yojson.Safe.json\n  val of_yojson : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val _ : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val equal : t -> t -> sexp_bool\nend"}
{"start":{"line":30,"col":11},"end":{"line":30,"col":14},"definition":{"file":"*buffer*","pos":{"line":29,"col":12}}}
{"start":{"line":30,"col":11},"end":{"line":30,"col":14},"type":"t"}
{"start":{"line":30,"col":15},"end":{"line":30,"col":18},"definition":{"file":"*buffer*","pos":{"line":29,"col":22}}}
{"start":{"line":30,"col":15},"end":{"line":30,"col":18},"type":"string"}
{"start":{"line":30,"col":2},"end":{"line":30,"col":10},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1275,"col":6}}}
{"start":{"line":30,"col":2},"end":{"line":30,"col":10},"type":"('k, 'v, 'cmp) Base.Map.t -> 'k -> 'v sexp_option"}
{"start":{"line":30,"col":2},"end":{"line":30,"col":5},"type":"(module Core.Map)"}
{"start":{"line":30,"col":2},"end":{"line":31,"col":46},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":30,"col":2},"end":{"line":31,"col":46},"type":"string sexp_option"}
{"start":{"line":31,"col":19},"end":{"line":31,"col":46},"type":"data -> string"}
{"start":{"line":31,"col":24},"end":{"line":31,"col":36},"type":"data"}
{"start":{"line":31,"col":26},"end":{"line":31,"col":31},"type":"string"}
{"start":{"line":31,"col":2},"end":{"line":31,"col":4},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":40,"col":0}}}
{"start":{"line":31,"col":2},"end":{"line":31,"col":4},"type":"data sexp_option ->\n(data sexp_option -> string sexp_option) -> string sexp_option"}
{"start":{"line":31,"col":40},"end":{"line":31,"col":45},"definition":{"file":"*buffer*","pos":{"line":31,"col":26}}}
{"start":{"line":31,"col":40},"end":{"line":31,"col":45},"type":"string"}
{"start":{"line":31,"col":5},"end":{"line":31,"col":11},"type":"(module Option)"}
{"start":{"line":31,"col":5},"end":{"line":31,"col":15},"definition":{"file":"/Users/rvt/.opam/default/lib/base/monad.ml","pos":{"line":30,"col":6}}}
{"start":{"line":31,"col":5},"end":{"line":31,"col":15},"type":"'a sexp_option -> f:('a -> 'b) -> 'b sexp_option"}
{"start":{"line":31,"col":5},"end":{"line":31,"col":46},"type":"data sexp_option -> string sexp_option"}
{"start":{"line":33,"col":18},"end":{"line":33,"col":21},"type":"t"}
{"start":{"line":33,"col":24},"end":{"line":33,"col":25},"definition":{"file":"*buffer*","pos":{"line":15,"col":0}}}
{"start":{"line":33,"col":24},"end":{"line":33,"col":25},"type":"type t = data Core.String.Map.t"}
{"start":{"line":33,"col":28},"end":{"line":33,"col":31},"type":"string"}
{"start":{"line":33,"col":34},"end":{"line":33,"col":40},"type":"type string"}
{"start":{"line":33,"col":44},"end":{"line":33,"col":49},"type":"(module Range)"}
{"start":{"line":33,"col":44},"end":{"line":33,"col":51},"definition":{"file":"/Users/rvt/official-comby/lib/match/range.ml","pos":{"line":1,"col":0}}}
{"start":{"line":33,"col":44},"end":{"line":33,"col":51},"type":"type t = Range.t = { match_start : Location.t; match_end : Location.t; }"}
{"start":{"line":33,"col":4},"end":{"line":33,"col":16},"type":"t -> string -> Range.t sexp_option"}
{"start":{"line":33,"col":52},"end":{"line":33,"col":58},"type":"type 'a option = None | Some of 'a"}
{"start":{"line":34,"col":11},"end":{"line":34,"col":14},"definition":{"file":"*buffer*","pos":{"line":33,"col":18}}}
{"start":{"line":34,"col":11},"end":{"line":34,"col":14},"type":"t"}
{"start":{"line":34,"col":15},"end":{"line":34,"col":18},"definition":{"file":"*buffer*","pos":{"line":33,"col":28}}}
{"start":{"line":34,"col":15},"end":{"line":34,"col":18},"type":"string"}
{"start":{"line":34,"col":2},"end":{"line":34,"col":10},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1275,"col":6}}}
{"start":{"line":34,"col":2},"end":{"line":34,"col":10},"type":"('k, 'v, 'cmp) Base.Map.t -> 'k -> 'v sexp_option"}
{"start":{"line":34,"col":2},"end":{"line":34,"col":5},"type":"(module Core.Map)"}
{"start":{"line":34,"col":2},"end":{"line":35,"col":46},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":34,"col":2},"end":{"line":35,"col":46},"type":"Range.t sexp_option"}
{"start":{"line":35,"col":19},"end":{"line":35,"col":46},"type":"data -> Range.t"}
{"start":{"line":35,"col":24},"end":{"line":35,"col":36},"type":"data"}
{"start":{"line":35,"col":26},"end":{"line":35,"col":31},"type":"Range.t"}
{"start":{"line":35,"col":2},"end":{"line":35,"col":4},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":40,"col":0}}}
{"start":{"line":35,"col":2},"end":{"line":35,"col":4},"type":"data sexp_option ->\n(data sexp_option -> Range.t sexp_option) -> Range.t sexp_option"}
{"start":{"line":35,"col":40},"end":{"line":35,"col":45},"definition":{"file":"*buffer*","pos":{"line":35,"col":26}}}
{"start":{"line":35,"col":40},"end":{"line":35,"col":45},"type":"Range.t"}
{"start":{"line":35,"col":5},"end":{"line":35,"col":11},"type":"(module Option)"}
{"start":{"line":35,"col":5},"end":{"line":35,"col":15},"definition":{"file":"/Users/rvt/.opam/default/lib/base/monad.ml","pos":{"line":30,"col":6}}}
{"start":{"line":35,"col":5},"end":{"line":35,"col":15},"type":"'a sexp_option -> f:('a -> 'b) -> 'b sexp_option"}
{"start":{"line":35,"col":5},"end":{"line":35,"col":46},"type":"data sexp_option -> Range.t sexp_option"}
{"start":{"line":37,"col":10},"end":{"line":37,"col":13},"type":"t"}
{"start":{"line":37,"col":10},"end":{"line":38,"col":14},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":37,"col":16},"end":{"line":37,"col":17},"definition":{"file":"*buffer*","pos":{"line":15,"col":0}}}
{"start":{"line":37,"col":16},"end":{"line":37,"col":17},"type":"type t = data Core.String.Map.t"}
{"start":{"line":37,"col":4},"end":{"line":37,"col":8},"type":"t -> init:'a -> f:(key:string -> data:data -> 'a -> 'a) -> 'a"}
{"start":{"line":37,"col":9},"end":{"line":38,"col":14},"type":"t -> init:'a -> f:(key:string -> data:data -> 'a -> 'a) -> 'a"}
{"start":{"line":38,"col":11},"end":{"line":38,"col":14},"definition":{"file":"*buffer*","pos":{"line":37,"col":10}}}
{"start":{"line":38,"col":11},"end":{"line":38,"col":14},"type":"t"}
{"start":{"line":38,"col":2},"end":{"line":38,"col":10},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1288,"col":6}}}
{"start":{"line":38,"col":2},"end":{"line":38,"col":10},"type":"('k, 'v, 'b) Base.Map.t -> init:'a -> f:(key:'k -> data:'v -> 'a -> 'a) -> 'a"}
{"start":{"line":38,"col":2},"end":{"line":38,"col":5},"type":"(module Core.Map)"}
{"start":{"line":4,"col":2},"end":{"line":8,"col":31},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":4,"col":2},"end":{"line":8,"col":31},"type":"bool -> bool -> bool"}
{"start":{"line":4,"col":7},"end":{"line":4,"col":8},"definition":{"file":"*buffer*","pos":{"line":4,"col":2}}}
{"start":{"line":4,"col":7},"end":{"line":4,"col":8},"type":"type t = { value : string; range : Range.t; }"}
{"start":{"line":40,"col":11},"end":{"line":40,"col":14},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":40,"col":15},"end":{"line":40,"col":18},"type":"'a"}
{"start":{"line":40,"col":19},"end":{"line":40,"col":24},"type":"string"}
{"start":{"line":40,"col":19},"end":{"line":41,"col":77},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":40,"col":19},"end":{"line":41,"col":77},"type":"string -> ('a, data, 'b) Base.Map.t"}
{"start":{"line":40,"col":4},"end":{"line":40,"col":10},"type":"('a, data, 'b) Base.Map.t -> 'a -> string -> ('a, data, 'b) Base.Map.t"}
{"start":{"line":41,"col":13},"end":{"line":41,"col":16},"definition":{"file":"*buffer*","pos":{"line":40,"col":11}}}
{"start":{"line":41,"col":13},"end":{"line":41,"col":16},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":41,"col":17},"end":{"line":41,"col":20},"definition":{"file":"*buffer*","pos":{"line":40,"col":15}}}
{"start":{"line":41,"col":17},"end":{"line":41,"col":20},"type":"'a"}
{"start":{"line":41,"col":24},"end":{"line":41,"col":77},"type":"data sexp_option -> data sexp_option"}
{"start":{"line":41,"col":25},"end":{"line":41,"col":31},"type":"(module Option)"}
{"start":{"line":41,"col":25},"end":{"line":41,"col":35},"definition":{"file":"/Users/rvt/.opam/default/lib/base/monad.ml","pos":{"line":30,"col":6}}}
{"start":{"line":41,"col":25},"end":{"line":41,"col":35},"type":"'a sexp_option -> f:('a -> 'b) -> 'b sexp_option"}
{"start":{"line":41,"col":2},"end":{"line":41,"col":12},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1270,"col":6}}}
{"start":{"line":41,"col":2},"end":{"line":41,"col":12},"type":"('k, 'v, 'cmp) Base.Map.t ->\n'k -> f:('v sexp_option -> 'v sexp_option) -> ('k, 'v, 'cmp) Base.Map.t"}
{"start":{"line":41,"col":2},"end":{"line":41,"col":5},"type":"(module Core.Map)"}
{"start":{"line":41,"col":2},"end":{"line":41,"col":77},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":41,"col":39},"end":{"line":41,"col":76},"type":"data -> data"}
{"start":{"line":41,"col":44},"end":{"line":41,"col":50},"type":"data"}
{"start":{"line":41,"col":54},"end":{"line":41,"col":75},"type":"data"}
{"start":{"line":41,"col":56},"end":{"line":41,"col":62},"definition":{"file":"*buffer*","pos":{"line":41,"col":44}}}
{"start":{"line":41,"col":56},"end":{"line":41,"col":62},"type":"data"}
{"start":{"line":41,"col":68},"end":{"line":41,"col":73},"definition":{"file":"*buffer*","pos":{"line":40,"col":19}}}
{"start":{"line":41,"col":68},"end":{"line":41,"col":73},"type":"string"}
{"start":{"line":43,"col":17},"end":{"line":43,"col":20},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":43,"col":21},"end":{"line":43,"col":24},"type":"'a"}
{"start":{"line":43,"col":25},"end":{"line":43,"col":30},"type":"Range.t"}
{"start":{"line":43,"col":25},"end":{"line":44,"col":77},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":43,"col":25},"end":{"line":44,"col":77},"type":"Range.t -> ('a, data, 'b) Base.Map.t"}
{"start":{"line":43,"col":4},"end":{"line":43,"col":16},"type":"('a, data, 'b) Base.Map.t -> 'a -> Range.t -> ('a, data, 'b) Base.Map.t"}
{"start":{"line":44,"col":13},"end":{"line":44,"col":16},"definition":{"file":"*buffer*","pos":{"line":43,"col":17}}}
{"start":{"line":44,"col":13},"end":{"line":44,"col":16},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":44,"col":17},"end":{"line":44,"col":20},"definition":{"file":"*buffer*","pos":{"line":43,"col":21}}}
{"start":{"line":44,"col":17},"end":{"line":44,"col":20},"type":"'a"}
{"start":{"line":44,"col":24},"end":{"line":44,"col":77},"type":"data sexp_option -> data sexp_option"}
{"start":{"line":44,"col":25},"end":{"line":44,"col":31},"type":"(module Option)"}
{"start":{"line":44,"col":25},"end":{"line":44,"col":35},"definition":{"file":"/Users/rvt/.opam/default/lib/base/monad.ml","pos":{"line":30,"col":6}}}
{"start":{"line":44,"col":25},"end":{"line":44,"col":35},"type":"'a sexp_option -> f:('a -> 'b) -> 'b sexp_option"}
{"start":{"line":44,"col":2},"end":{"line":44,"col":12},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1270,"col":6}}}
{"start":{"line":44,"col":2},"end":{"line":44,"col":12},"type":"('k, 'v, 'cmp) Base.Map.t ->\n'k -> f:('v sexp_option -> 'v sexp_option) -> ('k, 'v, 'cmp) Base.Map.t"}
{"start":{"line":44,"col":2},"end":{"line":44,"col":5},"type":"(module Core.Map)"}
{"start":{"line":44,"col":2},"end":{"line":44,"col":77},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":44,"col":39},"end":{"line":44,"col":76},"type":"data -> data"}
{"start":{"line":44,"col":44},"end":{"line":44,"col":50},"type":"data"}
{"start":{"line":44,"col":54},"end":{"line":44,"col":75},"type":"data"}
{"start":{"line":44,"col":56},"end":{"line":44,"col":62},"definition":{"file":"*buffer*","pos":{"line":44,"col":44}}}
{"start":{"line":44,"col":56},"end":{"line":44,"col":62},"type":"data"}
{"start":{"line":44,"col":68},"end":{"line":44,"col":73},"definition":{"file":"*buffer*","pos":{"line":43,"col":25}}}
{"start":{"line":44,"col":68},"end":{"line":44,"col":73},"type":"Range.t"}
{"start":{"line":46,"col":14},"end":{"line":46,"col":17},"type":"(string, data, 'a) Base.Map.t"}
{"start":{"line":46,"col":14},"end":{"line":48,"col":56},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":46,"col":14},"end":{"line":48,"col":56},"type":"(string, data, 'a) Base.Map.t -> string"}
{"start":{"line":46,"col":4},"end":{"line":46,"col":13},"type":"(string, data, 'a) Base.Map.t -> string"}
{"start":{"line":47,"col":11},"end":{"line":47,"col":14},"definition":{"file":"*buffer*","pos":{"line":46,"col":14}}}
{"start":{"line":47,"col":11},"end":{"line":47,"col":14},"type":"(string, data, 'a) Base.Map.t"}
{"start":{"line":47,"col":21},"end":{"line":47,"col":23},"type":"string"}
{"start":{"line":47,"col":27},"end":{"line":48,"col":56},"type":"key:string -> data:data -> string -> string"}
{"start":{"line":47,"col":2},"end":{"line":47,"col":10},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1288,"col":6}}}
{"start":{"line":47,"col":2},"end":{"line":47,"col":10},"type":"('k, 'v, 'b) Base.Map.t -> init:'a -> f:(key:'k -> data:'v -> 'a -> 'a) -> 'a"}
{"start":{"line":47,"col":2},"end":{"line":47,"col":5},"type":"(module Core.Map)"}
{"start":{"line":47,"col":2},"end":{"line":48,"col":56},"type":"string"}
{"start":{"line":47,"col":37},"end":{"line":47,"col":45},"type":"string"}
{"start":{"line":47,"col":46},"end":{"line":48,"col":55},"type":"data:data -> string -> string"}
{"start":{"line":47,"col":52},"end":{"line":47,"col":64},"type":"data"}
{"start":{"line":47,"col":54},"end":{"line":47,"col":59},"type":"string"}
{"start":{"line":47,"col":65},"end":{"line":47,"col":68},"type":"string"}
{"start":{"line":47,"col":65},"end":{"line":48,"col":55},"type":"string -> string"}
{"start":{"line":48,"col":21},"end":{"line":48,"col":36},"type":"string"}
{"start":{"line":48,"col":37},"end":{"line":48,"col":45},"definition":{"file":"*buffer*","pos":{"line":47,"col":37}}}
{"start":{"line":48,"col":37},"end":{"line":48,"col":45},"type":"string"}
{"start":{"line":48,"col":46},"end":{"line":48,"col":51},"definition":{"file":"*buffer*","pos":{"line":47,"col":54}}}
{"start":{"line":48,"col":46},"end":{"line":48,"col":51},"type":"string"}
{"start":{"line":48,"col":52},"end":{"line":48,"col":55},"definition":{"file":"*buffer*","pos":{"line":47,"col":65}}}
{"start":{"line":48,"col":52},"end":{"line":48,"col":55},"type":"string"}
{"start":{"line":48,"col":6},"end":{"line":48,"col":12},"type":"(module Format)"}
{"start":{"line":48,"col":6},"end":{"line":48,"col":20},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/format.ml","pos":{"line":1,"col":0}}}
{"start":{"line":48,"col":6},"end":{"line":48,"col":20},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/format.ml","pos":{"line":1357,"col":4}}}
{"start":{"line":48,"col":6},"end":{"line":48,"col":20},"type":"('a, unit, string) format -> 'a"}
{"start":{"line":48,"col":6},"end":{"line":48,"col":55},"type":"string"}
{"start":{"line":5,"col":14},"end":{"line":5,"col":20},"definition":{"file":"/Users/rvt/.opam/default/lib/ppx_deriving/runtime/ppx_deriving_runtime.ml","pos":{"line":21,"col":0}}}
{"start":{"line":5,"col":14},"end":{"line":5,"col":20},"type":"type string = bytes"}
{"start":{"line":5,"col":6},"end":{"line":5,"col":11},"definition":{"file":"*buffer*","pos":{"line":4,"col":2}}}
{"start":{"line":5,"col":6},"end":{"line":5,"col":11},"type":"string"}
{"start":{"line":5,"col":6},"end":{"line":6,"col":5},"type":"t"}
{"start":{"line":50,"col":19},"end":{"line":50,"col":22},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":50,"col":19},"end":{"line":55,"col":27},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":50,"col":19},"end":{"line":55,"col":27},"type":"('a, data, 'b) Base.Map.t -> int"}
{"start":{"line":50,"col":4},"end":{"line":50,"col":18},"type":"('a, data, 'b) Base.Map.t -> int"}
{"start":{"line":51,"col":2},"end":{"line":51,"col":10},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1288,"col":6}}}
{"start":{"line":51,"col":2},"end":{"line":51,"col":10},"type":"('k, 'v, 'b) Base.Map.t -> init:'a -> f:(key:'k -> data:'v -> 'a -> 'a) -> 'a"}
{"start":{"line":51,"col":2},"end":{"line":51,"col":5},"type":"(module Core.Map)"}
{"start":{"line":51,"col":2},"end":{"line":55,"col":27},"type":"int"}
{"start":{"line":52,"col":4},"end":{"line":52,"col":7},"definition":{"file":"*buffer*","pos":{"line":50,"col":19}}}
{"start":{"line":52,"col":4},"end":{"line":52,"col":7},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":53,"col":10},"end":{"line":53,"col":11},"type":"int"}
{"start":{"line":54,"col":17},"end":{"line":54,"col":18},"type":"'a"}
{"start":{"line":54,"col":19},"end":{"line":55,"col":26},"type":"data:data -> int -> int"}
{"start":{"line":54,"col":25},"end":{"line":54,"col":74},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":54,"col":25},"end":{"line":54,"col":74},"type":"data"}
{"start":{"line":54,"col":27},"end":{"line":54,"col":32},"definition":{"file":"*buffer*","pos":{"line":4,"col":2}}}
{"start":{"line":54,"col":35},"end":{"line":54,"col":69},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":54,"col":35},"end":{"line":54,"col":69},"type":"Range.t"}
{"start":{"line":54,"col":37},"end":{"line":54,"col":48},"definition":{"file":"/Users/rvt/official-comby/lib/match/range.ml","pos":{"line":1,"col":0}}}
{"start":{"line":54,"col":51},"end":{"line":54,"col":64},"type":"Location.t"}
{"start":{"line":54,"col":53},"end":{"line":54,"col":59},"type":"int"}
{"start":{"line":54,"col":75},"end":{"line":54,"col":78},"type":"int"}
{"start":{"line":54,"col":75},"end":{"line":55,"col":26},"type":"int -> int"}
{"start":{"line":54,"col":7},"end":{"line":55,"col":27},"type":"key:'a -> data:data -> int -> int"}
{"start":{"line":55,"col":16},"end":{"line":55,"col":22},"definition":{"file":"*buffer*","pos":{"line":54,"col":53}}}
{"start":{"line":55,"col":16},"end":{"line":55,"col":22},"type":"int"}
{"start":{"line":55,"col":23},"end":{"line":55,"col":26},"definition":{"file":"*buffer*","pos":{"line":54,"col":75}}}
{"start":{"line":55,"col":23},"end":{"line":55,"col":26},"type":"int"}
{"start":{"line":55,"col":8},"end":{"line":55,"col":11},"type":"(module Int)"}
{"start":{"line":55,"col":8},"end":{"line":55,"col":15},"definition":{"file":"/Users/rvt/.opam/default/lib/base/import0.ml","pos":{"line":194,"col":6}}}
{"start":{"line":55,"col":8},"end":{"line":55,"col":15},"type":"int -> int -> int"}
{"start":{"line":55,"col":8},"end":{"line":55,"col":26},"type":"int"}
{"start":{"line":57,"col":10},"end":{"line":57,"col":14},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":57,"col":15},"end":{"line":57,"col":19},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":57,"col":15},"end":{"line":58,"col":32},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":57,"col":15},"end":{"line":58,"col":32},"type":"('a, data, 'b) Base.Map.t -> sexp_bool"}
{"start":{"line":57,"col":4},"end":{"line":57,"col":9},"type":"('a, data, 'b) Base.Map.t -> ('a, data, 'b) Base.Map.t -> sexp_bool"}
{"start":{"line":58,"col":12},"end":{"line":58,"col":16},"type":"sig\n  type t = { value : string; range : Range.t; }\n  val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t\n  val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t\n  val to_yojson : t -> Yojson.Safe.json\n  val of_yojson : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val _ : Yojson.Safe.json -> t Ppx_deriving_yojson_runtime.error_or\n  val equal : t -> t -> sexp_bool\nend"}
{"start":{"line":58,"col":12},"end":{"line":58,"col":22},"definition":{"file":"*buffer*","pos":{"line":3,"col":0}}}
{"start":{"line":58,"col":12},"end":{"line":58,"col":22},"definition":{"file":"*buffer*","pos":{"line":4,"col":2}}}
{"start":{"line":58,"col":12},"end":{"line":58,"col":22},"type":"data -> data -> sexp_bool"}
{"start":{"line":58,"col":23},"end":{"line":58,"col":27},"definition":{"file":"*buffer*","pos":{"line":57,"col":10}}}
{"start":{"line":58,"col":23},"end":{"line":58,"col":27},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":58,"col":28},"end":{"line":58,"col":32},"definition":{"file":"*buffer*","pos":{"line":57,"col":15}}}
{"start":{"line":58,"col":28},"end":{"line":58,"col":32},"type":"('a, data, 'b) Base.Map.t"}
{"start":{"line":58,"col":2},"end":{"line":58,"col":11},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1315,"col":6}}}
{"start":{"line":58,"col":2},"end":{"line":58,"col":11},"type":"('v -> 'v -> sexp_bool) ->\n('k, 'v, 'cmp) Base.Map.t -> ('k, 'v, 'cmp) Base.Map.t -> sexp_bool"}
{"start":{"line":58,"col":2},"end":{"line":58,"col":5},"type":"(module Core.Map)"}
{"start":{"line":6,"col":14},"end":{"line":6,"col":19},"type":"(module Range)"}
{"start":{"line":6,"col":14},"end":{"line":6,"col":21},"type":"type t = Range.t = { match_start : Location.t; match_end : Location.t; }"}
{"start":{"line":6,"col":6},"end":{"line":6,"col":11},"definition":{"file":"*buffer*","pos":{"line":4,"col":2}}}
{"start":{"line":6,"col":6},"end":{"line":6,"col":11},"type":"Range.t"}
{"start":{"line":6,"col":6},"end":{"line":6,"col":21},"definition":{"file":"/Users/rvt/official-comby/lib/match/range.ml","pos":{"line":1,"col":0}}}
{"start":{"line":6,"col":6},"end":{"line":6,"col":21},"type":"Range.t -> Range.t -> sexp_bool"}
{"start":{"line":60,"col":10},"end":{"line":60,"col":14},"type":"('a, 'b, 'c) Base.Map.t"}
{"start":{"line":60,"col":15},"end":{"line":60,"col":19},"type":"('a, 'b, 'c) Base.Map.t"}
{"start":{"line":60,"col":15},"end":{"line":61,"col":61},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":60,"col":15},"end":{"line":61,"col":61},"type":"('a, 'b, 'c) Base.Map.t -> ('a, 'b, 'c) Base.Map.t"}
{"start":{"line":60,"col":4},"end":{"line":60,"col":9},"type":"('a, 'b, 'c) Base.Map.t -> ('a, 'b, 'c) Base.Map.t -> ('a, 'b, 'c) Base.Map.t"}
{"start":{"line":61,"col":19},"end":{"line":61,"col":23},"definition":{"file":"*buffer*","pos":{"line":60,"col":10}}}
{"start":{"line":61,"col":19},"end":{"line":61,"col":23},"type":"('a, 'b, 'c) Base.Map.t"}
{"start":{"line":61,"col":24},"end":{"line":61,"col":28},"definition":{"file":"*buffer*","pos":{"line":60,"col":15}}}
{"start":{"line":61,"col":24},"end":{"line":61,"col":28},"type":"('a, 'b, 'c) Base.Map.t"}
{"start":{"line":61,"col":2},"end":{"line":61,"col":18},"type":"('k, 'v, 'cmp) Base.Map.t ->\n('k, 'v, 'cmp) Base.Map.t ->\ncombine:(key:'k -> 'v -> 'v -> 'v) -> ('k, 'v, 'cmp) Base.Map.t"}
{"start":{"line":61,"col":2},"end":{"line":61,"col":5},"type":"(module Core.Map)"}
{"start":{"line":61,"col":2},"end":{"line":61,"col":61},"type":"('a, 'b, 'c) Base.Map.t"}
{"start":{"line":61,"col":38},"end":{"line":61,"col":61},"type":"key:'a -> 'b -> 'b -> 'b"}
{"start":{"line":61,"col":48},"end":{"line":61,"col":49},"type":"'a"}
{"start":{"line":61,"col":50},"end":{"line":61,"col":52},"type":"'a"}
{"start":{"line":61,"col":53},"end":{"line":61,"col":54},"type":"'a"}
{"start":{"line":61,"col":53},"end":{"line":61,"col":60},"type":"'a -> 'a"}
{"start":{"line":61,"col":58},"end":{"line":61,"col":60},"definition":{"file":"*buffer*","pos":{"line":61,"col":50}}}
{"start":{"line":61,"col":58},"end":{"line":61,"col":60},"type":"'a"}
{"start":{"line":63,"col":4},"end":{"line":63,"col":8},"type":"t -> t"}
{"start":{"line":63,"col":9},"end":{"line":63,"col":12},"type":"t"}
{"start":{"line":63,"col":9},"end":{"line":65,"col":32},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":63,"col":9},"end":{"line":65,"col":32},"type":"t -> t"}
{"start":{"line":64,"col":17},"end":{"line":64,"col":28},"type":"t"}
{"start":{"line":64,"col":18},"end":{"line":64,"col":24},"definition":{"file":"*buffer*","pos":{"line":17,"col":4}}}
{"start":{"line":64,"col":18},"end":{"line":64,"col":24},"type":"unit -> t"}
{"start":{"line":64,"col":25},"end":{"line":64,"col":27},"type":"unit"}
{"start":{"line":64,"col":2},"end":{"line":64,"col":6},"definition":{"file":"*buffer*","pos":{"line":37,"col":4}}}
{"start":{"line":64,"col":2},"end":{"line":64,"col":6},"type":"t -> init:'a -> f:(key:string -> data:data -> 'a -> 'a) -> 'a"}
{"start":{"line":64,"col":2},"end":{"line":65,"col":32},"type":"t"}
{"start":{"line":64,"col":32},"end":{"line":65,"col":32},"type":"key:string -> data:data -> t -> t"}
{"start":{"line":64,"col":38},"end":{"line":64,"col":41},"type":"string"}
{"start":{"line":64,"col":42},"end":{"line":65,"col":31},"type":"data:data -> t -> t"}
{"start":{"line":64,"col":48},"end":{"line":64,"col":64},"type":"data"}
{"start":{"line":64,"col":50},"end":{"line":64,"col":55},"type":"string"}
{"start":{"line":64,"col":57},"end":{"line":64,"col":62},"type":"Range.t"}
{"start":{"line":64,"col":65},"end":{"line":64,"col":69},"type":"t"}
{"start":{"line":64,"col":65},"end":{"line":65,"col":31},"type":"t -> t"}
{"start":{"line":64,"col":7},"end":{"line":64,"col":10},"definition":{"file":"*buffer*","pos":{"line":63,"col":9}}}
{"start":{"line":64,"col":7},"end":{"line":64,"col":10},"type":"t"}
{"start":{"line":65,"col":11},"end":{"line":65,"col":16},"definition":{"file":"*buffer*","pos":{"line":64,"col":57}}}
{"start":{"line":65,"col":11},"end":{"line":65,"col":16},"type":"Range.t"}
{"start":{"line":65,"col":17},"end":{"line":65,"col":21},"definition":{"file":"*buffer*","pos":{"line":64,"col":65}}}
{"start":{"line":65,"col":17},"end":{"line":65,"col":21},"type":"t"}
{"start":{"line":65,"col":22},"end":{"line":65,"col":25},"definition":{"file":"*buffer*","pos":{"line":64,"col":38}}}
{"start":{"line":65,"col":22},"end":{"line":65,"col":25},"type":"string"}
{"start":{"line":65,"col":26},"end":{"line":65,"col":31},"definition":{"file":"*buffer*","pos":{"line":64,"col":50}}}
{"start":{"line":65,"col":26},"end":{"line":65,"col":31},"type":"string"}
{"start":{"line":65,"col":6},"end":{"line":65,"col":31},"type":"t"}
{"start":{"line":65,"col":6},"end":{"line":65,"col":9},"definition":{"file":"*buffer*","pos":{"line":23,"col":4}}}
{"start":{"line":65,"col":6},"end":{"line":65,"col":9},"type":"?range:Range.t -> t -> string -> string -> t"}
{"start":{"line":67,"col":14},"end":{"line":67,"col":17},"type":"(string, data, 'a) Base.Map.t"}
{"start":{"line":67,"col":20},"end":{"line":67,"col":26},"type":"sig\n  val version : string\n  exception Json_error of string\n  val json_error : string -> 'a\n  type lexer_state = {\n    buf : Bi_outbuf.t;\n    mutable lnum : int;\n    mutable bol : int;\n    mutable fname : string sexp_option;\n  }\n  module Lexer_state :\n    sig\n      type t =\n        lexer_state = {\n        buf : Bi_outbuf.t;\n        mutable lnum : int;\n        mutable bol : int;\n        mutable fname : string sexp_option;\n      }\n    end\n  val init_lexer :\n    ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> unit -> lexer_state\n  exception End_of_array\n  exception End_of_object\n  exception End_of_tuple\n  exception End_of_input\n  module Basic :\n    sig\n      type json =\n          [ `Assoc of (string * json) sexp_list\n          | `Bool of sexp_bool\n          | `Float of float\n          | `Int of int\n          | `List of json sexp_list\n          | `Null\n          | `String of string ]\n      val to_string :\n        ?buf:Bi_outbuf.t -> ?len:int -> ?std:sexp_bool -> json -> string\n      val to_channel :\n        ?buf:Bi_outbuf.t ->\n        ?len:int -> ?std:sexp_bool -> Pervasives.out_channel -> json -> unit\n      val to_output :\n        ?buf:Bi_outbuf.t ->\n        ?len:int ->\n        ?std:sexp_bool ->\n        < output : string -> int -> int -> int; .. > -> json -> unit\n      val to_file : ?len:int -> ?std:sexp_bool -> string -> json -> unit\n      val to_outbuf : ?std:sexp_bool -> Bi_outbuf.t -> json -> unit\n      val stream_to_string :\n        ?buf:Bi_outbuf.t ->\n        ?len:int -> ?std:sexp_bool -> json Stream.t -> string\n      val stream_to_channel :\n        ?buf:Bi_outbuf.t ->\n        ?len:int ->\n        ?std:sexp_bool -> Pervasives.out_channel -> json Stream.t -> unit\n      val stream_to_file :\n        ?len:int -> ?std:sexp_bool -> string -> json Stream.t -> unit\n      val stream_to_outbuf :\n        ?std:sexp_bool -> Bi_outbuf.t -> json Stream.t -> unit\n      val sort : json -> json\n      val write_null : Bi_outbuf.t -> unit -> unit\n      val write_bool : Bi_outbuf.t -> sexp_bool -> unit\n      val write_int : Bi_outbuf.t -> int -> unit\n      val write_float : Bi_outbuf.t -> float -> unit\n      val write_std_float : Bi_outbuf.t -> float -> unit\n      val write_float_fast : Bi_outbuf.t -> float -> unit\n      val write_std_float_fast : Bi_outbuf.t -> float -> unit\n      val write_float_prec : int -> Bi_outbuf.t -> float -> unit\n      val write_std_float_prec : int -> Bi_outbuf.t -> float -> unit\n      val write_string : Bi_outbuf.t -> string -> unit\n      val write_assoc : Bi_outbuf.t -> (string * json) sexp_list -> unit\n      val write_list : Bi_outbuf.t -> json sexp_list -> unit\n      val write_json : Bi_outbuf.t -> json -> unit\n      val write_std_json : Bi_outbuf.t -> json -> unit\n      val pretty_format : ?std:sexp_bool -> json -> Easy_format.t\n      val pretty_print : ?std:sexp_bool -> Format.formatter -> json -> unit\n      val pretty_to_string : ?std:sexp_bool -> json -> string\n      val pretty_to_channel :\n        ?std:sexp_bool -> Pervasives.out_channel -> json -> unit\n      val prettify : ?std:sexp_bool -> string -> string\n      val compact : ?std:sexp_bool -> string -> string\n      exception Finally of exn * exn\n      val from_string :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json\n      val from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json\n      val from_file :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json\n      type lexer_state =\n        Lexer_state.t = {\n        buf : Bi_outbuf.t;\n        mutable lnum : int;\n        mutable bol : int;\n        mutable fname : string sexp_option;\n      }\n      val init_lexer :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> unit -> lexer_state\n      val from_lexbuf :\n        lexer_state -> ?stream:sexp_bool -> Lexing.lexbuf -> json\n      val stream_from_string :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json Stream.t\n      val stream_from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fin:(unit -> unit) ->\n        ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json Stream.t\n      val stream_from_file :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json Stream.t\n      val stream_from_lexbuf :\n        lexer_state -> ?fin:(unit -> unit) -> Lexing.lexbuf -> json Stream.t\n      type json_line = [ `Exn of exn | `Json of json ]\n      val linestream_from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fin:(unit -> unit) ->\n        ?fname:string ->\n        ?lnum:int -> Pervasives.in_channel -> json_line Stream.t\n      val linestream_from_file :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json_line Stream.t\n      val finish_string : lexer_state -> Lexing.lexbuf -> string\n      val read_string : lexer_state -> Lexing.lexbuf -> string\n      val read_ident : lexer_state -> Lexing.lexbuf -> string\n      val map_string :\n        lexer_state -> (string -> int -> int -> 'a) -> Lexing.lexbuf -> 'a\n      val map_ident :\n        lexer_state -> (string -> int -> int -> 'a) -> Lexing.lexbuf -> 'a\n      type variant_kind = [ `Double_quote | `Edgy_bracket | `Square_bracket ]\n      val start_any_variant : lexer_state -> Lexing.lexbuf -> variant_kind\n      val finish_variant : lexer_state -> Lexing.lexbuf -> json sexp_option\n      val finish_skip_variant : lexer_state -> Lexing.lexbuf -> unit\n      val read_lt : lexer_state -> Lexing.lexbuf -> unit\n      val read_gt : lexer_state -> Lexing.lexbuf -> unit\n      val read_comma : lexer_state -> Lexing.lexbuf -> unit\n      val finish_stringlit : lexer_state -> Lexing.lexbuf -> string\n      val finish_skip_stringlit : lexer_state -> Lexing.lexbuf -> unit\n      val finish_escaped_char : lexer_state -> Lexing.lexbuf -> unit\n      val finish_comment : lexer_state -> Lexing.lexbuf -> unit\n      val read_space : lexer_state -> Lexing.lexbuf -> unit\n      val read_eof : Lexing.lexbuf -> sexp_bool\n      val read_null : lexer_state -> Lexing.lexbuf -> unit\n      val read_null_if_possible : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_bool : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_int : lexer_state -> Lexing.lexbuf -> int\n      val read_int8 : lexer_state -> Lexing.lexbuf -> char\n      val read_int32 : lexer_state -> Lexing.lexbuf -> int32\n      val read_int64 : lexer_state -> Lexing.lexbuf -> int64\n      val read_number : lexer_state -> Lexing.lexbuf -> float\n      val skip_ident : lexer_state -> Lexing.lexbuf -> unit\n      val read_sequence :\n        ('a -> lexer_state -> Lexing.lexbuf -> 'a) ->\n        'a -> lexer_state -> Lexing.lexbuf -> 'a\n      val read_list :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a sexp_list\n      val read_list_rev :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a sexp_list\n      val read_array_end : Lexing.lexbuf -> unit\n      val read_array_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_array :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a array\n      val read_tuple :\n        (int -> 'a -> lexer_state -> Lexing.lexbuf -> 'a) ->\n        'a -> lexer_state -> Lexing.lexbuf -> 'a\n      val start_any_tuple : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_lpar : lexer_state -> Lexing.lexbuf -> unit\n      val read_rpar : lexer_state -> Lexing.lexbuf -> unit\n      val read_tuple_end : Lexing.lexbuf -> unit\n      val read_tuple_end2 : lexer_state -> sexp_bool -> Lexing.lexbuf -> unit\n      val read_tuple_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_tuple_sep2 : lexer_state -> sexp_bool -> Lexing.lexbuf -> unit\n      val read_lbr : lexer_state -> Lexing.lexbuf -> unit\n      val read_rbr : lexer_state -> Lexing.lexbuf -> unit\n      val read_fields :\n        ('acc -> string -> lexer_state -> Lexing.lexbuf -> 'acc) ->\n        'acc -> lexer_state -> Lexing.lexbuf -> 'acc\n      val read_abstract_fields :\n        (lexer_state -> Lexing.lexbuf -> 'key) ->\n        ('acc -> 'key -> lexer_state -> Lexing.lexbuf -> 'acc) ->\n        'acc -> lexer_state -> Lexing.lexbuf -> 'acc\n      val read_lcurl : lexer_state -> Lexing.lexbuf -> unit\n      val read_object_end : Lexing.lexbuf -> unit\n      val read_object_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_colon : lexer_state -> Lexing.lexbuf -> unit\n      val read_json : lexer_state -> Lexing.lexbuf -> json\n      val skip_json : lexer_state -> Lexing.lexbuf -> unit\n      val buffer_json : lexer_state -> Lexing.lexbuf -> unit\n      val validate_json : 'path -> json -> 'error sexp_option\n      module Util :\n        sig\n          exception Type_error of string * json\n          exception Undefined of string * json\n          val ( |> ) : 'a -> ('a -> 'b) -> 'b\n          val keys : json -> string sexp_list\n          val values : json -> json sexp_list\n          val combine : json -> json -> json\n          val member : string -> json -> json\n          val index : int -> json -> json\n          val map : (json -> json) -> json -> json\n          val to_assoc : json -> (string * json) sexp_list\n          val to_option : (json -> 'a) -> json -> 'a sexp_option\n          val to_bool : json -> sexp_bool\n          val to_bool_option : json -> sexp_bool sexp_option\n          val to_number : json -> float\n          val to_number_option : json -> float sexp_option\n          val to_float : json -> float\n          val to_float_option : json -> float sexp_option\n          val to_int : json -> int\n          val to_int_option : json -> int sexp_option\n          val to_list : json -> json sexp_list\n          val to_string : json -> string\n          val to_string_option : json -> string sexp_option\n          val convert_each : (json -> 'a) -> json -> 'a sexp_list\n          val filter_map :\n            ('a -> 'b sexp_option) -> 'a sexp_list -> 'b sexp_list\n          val flatten : json sexp_list -> json sexp_list\n          val filter_index : int -> json sexp_list -> json sexp_list\n          val filter_list : json sexp_list -> json sexp_list sexp_list\n          val filter_member : string -> json sexp_list -> json sexp_list\n          val filter_assoc :\n            json sexp_list -> (string * json) sexp_list sexp_list\n          val filter_bool : json sexp_list -> sexp_bool sexp_list\n          val filter_int : json sexp_list -> int sexp_list\n          val filter_float : json sexp_list -> float sexp_list\n          val filter_number : json sexp_list -> float sexp_list\n          val filter_string : json sexp_list -> string sexp_list\n        end\n    end\n  module Safe :\n    sig\n      type json =\n          [ `Assoc of (string * json) sexp_list\n          | `Bool of sexp_bool\n          | `Float of float\n          | `Int of int\n          | `Intlit of string\n          | `List of json sexp_list\n          | `Null\n          | `String of string\n          | `Tuple of json sexp_list\n          | `Variant of string * json sexp_option ]\n      val to_basic : json -> Basic.json\n      val to_string :\n        ?buf:Bi_outbuf.t -> ?len:int -> ?std:sexp_bool -> json -> string\n      val to_channel :\n        ?buf:Bi_outbuf.t ->\n        ?len:int -> ?std:sexp_bool -> Pervasives.out_channel -> json -> unit\n      val to_output :\n        ?buf:Bi_outbuf.t ->\n        ?len:int ->\n        ?std:sexp_bool ->\n        < output : string -> int -> int -> int; .. > -> json -> unit\n      val to_file : ?len:int -> ?std:sexp_bool -> string -> json -> unit\n      val to_outbuf : ?std:sexp_bool -> Bi_outbuf.t -> json -> unit\n      val stream_to_string :\n        ?buf:Bi_outbuf.t ->\n        ?len:int -> ?std:sexp_bool -> json Stream.t -> string\n      val stream_to_channel :\n        ?buf:Bi_outbuf.t ->\n        ?len:int ->\n        ?std:sexp_bool -> Pervasives.out_channel -> json Stream.t -> unit\n      val stream_to_file :\n        ?len:int -> ?std:sexp_bool -> string -> json Stream.t -> unit\n      val stream_to_outbuf :\n        ?std:sexp_bool -> Bi_outbuf.t -> json Stream.t -> unit\n      val sort : json -> json\n      val write_null : Bi_outbuf.t -> unit -> unit\n      val write_bool : Bi_outbuf.t -> sexp_bool -> unit\n      val write_int : Bi_outbuf.t -> int -> unit\n      val write_float : Bi_outbuf.t -> float -> unit\n      val write_std_float : Bi_outbuf.t -> float -> unit\n      val write_float_fast : Bi_outbuf.t -> float -> unit\n      val write_std_float_fast : Bi_outbuf.t -> float -> unit\n      val write_float_prec : int -> Bi_outbuf.t -> float -> unit\n      val write_std_float_prec : int -> Bi_outbuf.t -> float -> unit\n      val write_string : Bi_outbuf.t -> string -> unit\n      val write_intlit : Bi_outbuf.t -> string -> unit\n      val write_assoc : Bi_outbuf.t -> (string * json) sexp_list -> unit\n      val write_list : Bi_outbuf.t -> json sexp_list -> unit\n      val write_tuple : Bi_outbuf.t -> json sexp_list -> unit\n      val write_std_tuple : Bi_outbuf.t -> json sexp_list -> unit\n      val write_variant : Bi_outbuf.t -> string -> json sexp_option -> unit\n      val write_std_variant :\n        Bi_outbuf.t -> string -> json sexp_option -> unit\n      val write_json : Bi_outbuf.t -> json -> unit\n      val write_std_json : Bi_outbuf.t -> json -> unit\n      val pretty_format : ?std:sexp_bool -> json -> Easy_format.t\n      val pretty_print : ?std:sexp_bool -> Format.formatter -> json -> unit\n      val pretty_to_string : ?std:sexp_bool -> json -> string\n      val pretty_to_channel :\n        ?std:sexp_bool -> Pervasives.out_channel -> json -> unit\n      val prettify : ?std:sexp_bool -> string -> string\n      val compact : ?std:sexp_bool -> string -> string\n      exception Finally of exn * exn\n      val from_string :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json\n      val from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json\n      val from_file :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json\n      type lexer_state =\n        Basic.lexer_state = {\n        buf : Bi_outbuf.t;\n        mutable lnum : int;\n        mutable bol : int;\n        mutable fname : string sexp_option;\n      }\n      val init_lexer :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> unit -> lexer_state\n      val from_lexbuf :\n        lexer_state -> ?stream:sexp_bool -> Lexing.lexbuf -> json\n      val stream_from_string :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json Stream.t\n      val stream_from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fin:(unit -> unit) ->\n        ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json Stream.t\n      val stream_from_file :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json Stream.t\n      val stream_from_lexbuf :\n        lexer_state -> ?fin:(unit -> unit) -> Lexing.lexbuf -> json Stream.t\n      type json_line = [ `Exn of exn | `Json of json ]\n      val linestream_from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fin:(unit -> unit) ->\n        ?fname:string ->\n        ?lnum:int -> Pervasives.in_channel -> json_line Stream.t\n      val linestream_from_file :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json_line Stream.t\n      val finish_string : lexer_state -> Lexing.lexbuf -> string\n      val read_string : lexer_state -> Lexing.lexbuf -> string\n      val read_ident : lexer_state -> Lexing.lexbuf -> string\n      val map_string :\n        lexer_state -> (string -> int -> int -> 'a) -> Lexing.lexbuf -> 'a\n      val map_ident :\n        lexer_state -> (string -> int -> int -> 'a) -> Lexing.lexbuf -> 'a\n      type variant_kind = [ `Double_quote | `Edgy_bracket | `Square_bracket ]\n      val start_any_variant : lexer_state -> Lexing.lexbuf -> variant_kind\n      val finish_variant : lexer_state -> Lexing.lexbuf -> json sexp_option\n      val finish_skip_variant : lexer_state -> Lexing.lexbuf -> unit\n      val read_lt : lexer_state -> Lexing.lexbuf -> unit\n      val read_gt : lexer_state -> Lexing.lexbuf -> unit\n      val read_comma : lexer_state -> Lexing.lexbuf -> unit\n      val finish_stringlit : lexer_state -> Lexing.lexbuf -> string\n      val finish_skip_stringlit : lexer_state -> Lexing.lexbuf -> unit\n      val finish_escaped_char : lexer_state -> Lexing.lexbuf -> unit\n      val finish_comment : lexer_state -> Lexing.lexbuf -> unit\n      val read_space : lexer_state -> Lexing.lexbuf -> unit\n      val read_eof : Lexing.lexbuf -> sexp_bool\n      val read_null : lexer_state -> Lexing.lexbuf -> unit\n      val read_null_if_possible : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_bool : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_int : lexer_state -> Lexing.lexbuf -> int\n      val read_int8 : lexer_state -> Lexing.lexbuf -> char\n      val read_int32 : lexer_state -> Lexing.lexbuf -> int32\n      val read_int64 : lexer_state -> Lexing.lexbuf -> int64\n      val read_number : lexer_state -> Lexing.lexbuf -> float\n      val skip_ident : lexer_state -> Lexing.lexbuf -> unit\n      val read_sequence :\n        ('a -> lexer_state -> Lexing.lexbuf -> 'a) ->\n        'a -> lexer_state -> Lexing.lexbuf -> 'a\n      val read_list :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a sexp_list\n      val read_list_rev :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a sexp_list\n      val read_array_end : Lexing.lexbuf -> unit\n      val read_array_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_array :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a array\n      val read_tuple :\n        (int -> 'a -> lexer_state -> Lexing.lexbuf -> 'a) ->\n        'a -> lexer_state -> Lexing.lexbuf -> 'a\n      val start_any_tuple : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_lpar : lexer_state -> Lexing.lexbuf -> unit\n      val read_rpar : lexer_state -> Lexing.lexbuf -> unit\n      val read_tuple_end : Lexing.lexbuf -> unit\n      val read_tuple_end2 : lexer_state -> sexp_bool -> Lexing.lexbuf -> unit\n      val read_tuple_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_tuple_sep2 : lexer_state -> sexp_bool -> Lexing.lexbuf -> unit\n      val read_lbr : lexer_state -> Lexing.lexbuf -> unit\n      val read_rbr : lexer_state -> Lexing.lexbuf -> unit\n      val read_fields :\n        ('acc -> string -> lexer_state -> Lexing.lexbuf -> 'acc) ->\n        'acc -> lexer_state -> Lexing.lexbuf -> 'acc\n      val read_abstract_fields :\n        (lexer_state -> Lexing.lexbuf -> 'key) ->\n        ('acc -> 'key -> lexer_state -> Lexing.lexbuf -> 'acc) ->\n        'acc -> lexer_state -> Lexing.lexbuf -> 'acc\n      val read_lcurl : lexer_state -> Lexing.lexbuf -> unit\n      val read_object_end : Lexing.lexbuf -> unit\n      val read_object_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_colon : lexer_state -> Lexing.lexbuf -> unit\n      val read_json : lexer_state -> Lexing.lexbuf -> json\n      val skip_json : lexer_state -> Lexing.lexbuf -> unit\n      val buffer_json : lexer_state -> Lexing.lexbuf -> unit\n      val validate_json : 'path -> json -> 'error sexp_option\n      module Util :\n        sig\n          exception Type_error of string * json\n          exception Undefined of string * json\n          val ( |> ) : 'a -> ('a -> 'b) -> 'b\n          val keys : json -> string sexp_list\n          val values : json -> json sexp_list\n          val combine : json -> json -> json\n          val member : string -> json -> json\n          val index : int -> json -> json\n          val map : (json -> json) -> json -> json\n          val to_assoc : json -> (string * json) sexp_list\n          val to_option : (json -> 'a) -> json -> 'a sexp_option\n          val to_bool : json -> sexp_bool\n          val to_bool_option : json -> sexp_bool sexp_option\n          val to_number : json -> float\n          val to_number_option : json -> float sexp_option\n          val to_float : json -> float\n          val to_float_option : json -> float sexp_option\n          val to_int : json -> int\n          val to_int_option : json -> int sexp_option\n          val to_list : json -> json sexp_list\n          val to_string : json -> string\n          val to_string_option : json -> string sexp_option\n          val convert_each : (json -> 'a) -> json -> 'a sexp_list\n          val filter_map :\n            ('a -> 'b sexp_option) -> 'a sexp_list -> 'b sexp_list\n          val flatten : json sexp_list -> json sexp_list\n          val filter_index : int -> json sexp_list -> json sexp_list\n          val filter_list : json sexp_list -> json sexp_list sexp_list\n          val filter_member : string -> json sexp_list -> json sexp_list\n          val filter_assoc :\n            json sexp_list -> (string * json) sexp_list sexp_list\n          val filter_bool : json sexp_list -> sexp_bool sexp_list\n          val filter_int : json sexp_list -> int sexp_list\n          val filter_float : json sexp_list -> float sexp_list\n          val filter_number : json sexp_list -> float sexp_list\n          val filter_string : json sexp_list -> string sexp_list\n        end\n    end\n  module Raw :\n    sig\n      type json =\n          [ `Assoc of (string * json) sexp_list\n          | `Bool of sexp_bool\n          | `Floatlit of string\n          | `Intlit of string\n          | `List of json sexp_list\n          | `Null\n          | `Stringlit of string\n          | `Tuple of json sexp_list\n          | `Variant of string * json sexp_option ]\n      val to_string :\n        ?buf:Bi_outbuf.t -> ?len:int -> ?std:sexp_bool -> json -> string\n      val to_channel :\n        ?buf:Bi_outbuf.t ->\n        ?len:int -> ?std:sexp_bool -> Pervasives.out_channel -> json -> unit\n      val to_output :\n        ?buf:Bi_outbuf.t ->\n        ?len:int ->\n        ?std:sexp_bool ->\n        < output : string -> int -> int -> int; .. > -> json -> unit\n      val to_file : ?len:int -> ?std:sexp_bool -> string -> json -> unit\n      val to_outbuf : ?std:sexp_bool -> Bi_outbuf.t -> json -> unit\n      val stream_to_string :\n        ?buf:Bi_outbuf.t ->\n        ?len:int -> ?std:sexp_bool -> json Stream.t -> string\n      val stream_to_channel :\n        ?buf:Bi_outbuf.t ->\n        ?len:int ->\n        ?std:sexp_bool -> Pervasives.out_channel -> json Stream.t -> unit\n      val stream_to_file :\n        ?len:int -> ?std:sexp_bool -> string -> json Stream.t -> unit\n      val stream_to_outbuf :\n        ?std:sexp_bool -> Bi_outbuf.t -> json Stream.t -> unit\n      val sort : json -> json\n      val write_null : Bi_outbuf.t -> unit -> unit\n      val write_bool : Bi_outbuf.t -> sexp_bool -> unit\n      val write_intlit : Bi_outbuf.t -> string -> unit\n      val write_floatlit : Bi_outbuf.t -> string -> unit\n      val write_stringlit : Bi_outbuf.t -> string -> unit\n      val write_assoc : Bi_outbuf.t -> (string * json) sexp_list -> unit\n      val write_list : Bi_outbuf.t -> json sexp_list -> unit\n      val write_tuple : Bi_outbuf.t -> json sexp_list -> unit\n      val write_std_tuple : Bi_outbuf.t -> json sexp_list -> unit\n      val write_variant : Bi_outbuf.t -> string -> json sexp_option -> unit\n      val write_std_variant :\n        Bi_outbuf.t -> string -> json sexp_option -> unit\n      val write_json : Bi_outbuf.t -> json -> unit\n      val write_std_json : Bi_outbuf.t -> json -> unit\n      val pretty_format : ?std:sexp_bool -> json -> Easy_format.t\n      val pretty_print : ?std:sexp_bool -> Format.formatter -> json -> unit\n      val pretty_to_string : ?std:sexp_bool -> json -> string\n      val pretty_to_channel :\n        ?std:sexp_bool -> Pervasives.out_channel -> json -> unit\n      val prettify : ?std:sexp_bool -> string -> string\n      val compact : ?std:sexp_bool -> string -> string\n      exception Finally of exn * exn\n      val from_string :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json\n      val from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json\n      val from_file :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json\n      type lexer_state =\n        Safe.lexer_state = {\n        buf : Bi_outbuf.t;\n        mutable lnum : int;\n        mutable bol : int;\n        mutable fname : string sexp_option;\n      }\n      val init_lexer :\n        ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> unit -> lexer_state\n      val from_lexbuf :\n        lexer_state -> ?stream:sexp_bool -> Lexing.lexbuf -> json\n      val stream_from_string :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json Stream.t\n      val stream_from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fin:(unit -> unit) ->\n        ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json Stream.t\n      val stream_from_file :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json Stream.t\n      val stream_from_lexbuf :\n        lexer_state -> ?fin:(unit -> unit) -> Lexing.lexbuf -> json Stream.t\n      type json_line = [ `Exn of exn | `Json of json ]\n      val linestream_from_channel :\n        ?buf:Bi_outbuf.t ->\n        ?fin:(unit -> unit) ->\n        ?fname:string ->\n        ?lnum:int -> Pervasives.in_channel -> json_line Stream.t\n      val linestream_from_file :\n        ?buf:Bi_outbuf.t ->\n        ?fname:string -> ?lnum:int -> string -> json_line Stream.t\n      val finish_string : lexer_state -> Lexing.lexbuf -> string\n      val read_string : lexer_state -> Lexing.lexbuf -> string\n      val read_ident : lexer_state -> Lexing.lexbuf -> string\n      val map_string :\n        lexer_state -> (string -> int -> int -> 'a) -> Lexing.lexbuf -> 'a\n      val map_ident :\n        lexer_state -> (string -> int -> int -> 'a) -> Lexing.lexbuf -> 'a\n      type variant_kind = [ `Double_quote | `Edgy_bracket | `Square_bracket ]\n      val start_any_variant : lexer_state -> Lexing.lexbuf -> variant_kind\n      val finish_variant : lexer_state -> Lexing.lexbuf -> json sexp_option\n      val finish_skip_variant : lexer_state -> Lexing.lexbuf -> unit\n      val read_lt : lexer_state -> Lexing.lexbuf -> unit\n      val read_gt : lexer_state -> Lexing.lexbuf -> unit\n      val read_comma : lexer_state -> Lexing.lexbuf -> unit\n      val finish_stringlit : lexer_state -> Lexing.lexbuf -> string\n      val finish_skip_stringlit : lexer_state -> Lexing.lexbuf -> unit\n      val finish_escaped_char : lexer_state -> Lexing.lexbuf -> unit\n      val finish_comment : lexer_state -> Lexing.lexbuf -> unit\n      val read_space : lexer_state -> Lexing.lexbuf -> unit\n      val read_eof : Lexing.lexbuf -> sexp_bool\n      val read_null : lexer_state -> Lexing.lexbuf -> unit\n      val read_null_if_possible : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_bool : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_int : lexer_state -> Lexing.lexbuf -> int\n      val read_int8 : lexer_state -> Lexing.lexbuf -> char\n      val read_int32 : lexer_state -> Lexing.lexbuf -> int32\n      val read_int64 : lexer_state -> Lexing.lexbuf -> int64\n      val read_number : lexer_state -> Lexing.lexbuf -> float\n      val skip_ident : lexer_state -> Lexing.lexbuf -> unit\n      val read_sequence :\n        ('a -> lexer_state -> Lexing.lexbuf -> 'a) ->\n        'a -> lexer_state -> Lexing.lexbuf -> 'a\n      val read_list :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a sexp_list\n      val read_list_rev :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a sexp_list\n      val read_array_end : Lexing.lexbuf -> unit\n      val read_array_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_array :\n        (lexer_state -> Lexing.lexbuf -> 'a) ->\n        lexer_state -> Lexing.lexbuf -> 'a array\n      val read_tuple :\n        (int -> 'a -> lexer_state -> Lexing.lexbuf -> 'a) ->\n        'a -> lexer_state -> Lexing.lexbuf -> 'a\n      val start_any_tuple : lexer_state -> Lexing.lexbuf -> sexp_bool\n      val read_lpar : lexer_state -> Lexing.lexbuf -> unit\n      val read_rpar : lexer_state -> Lexing.lexbuf -> unit\n      val read_tuple_end : Lexing.lexbuf -> unit\n      val read_tuple_end2 : lexer_state -> sexp_bool -> Lexing.lexbuf -> unit\n      val read_tuple_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_tuple_sep2 : lexer_state -> sexp_bool -> Lexing.lexbuf -> unit\n      val read_lbr : lexer_state -> Lexing.lexbuf -> unit\n      val read_rbr : lexer_state -> Lexing.lexbuf -> unit\n      val read_fields :\n        ('acc -> string -> lexer_state -> Lexing.lexbuf -> 'acc) ->\n        'acc -> lexer_state -> Lexing.lexbuf -> 'acc\n      val read_abstract_fields :\n        (lexer_state -> Lexing.lexbuf -> 'key) ->\n        ('acc -> 'key -> lexer_state -> Lexing.lexbuf -> 'acc) ->\n        'acc -> lexer_state -> Lexing.lexbuf -> 'acc\n      val read_lcurl : lexer_state -> Lexing.lexbuf -> unit\n      val read_object_end : Lexing.lexbuf -> unit\n      val read_object_sep : lexer_state -> Lexing.lexbuf -> unit\n      val read_colon : lexer_state -> Lexing.lexbuf -> unit\n      val read_json : lexer_state -> Lexing.lexbuf -> json\n      val skip_json : lexer_state -> Lexing.lexbuf -> unit\n      val buffer_json : lexer_state -> Lexing.lexbuf -> unit\n      val validate_json : 'path -> json -> 'error sexp_option\n    end\n  type json =\n      [ `Assoc of (string * json) sexp_list\n      | `Bool of sexp_bool\n      | `Float of float\n      | `Floatlit of string\n      | `Int of int\n      | `Intlit of string\n      | `List of json sexp_list\n      | `Null\n      | `String of string\n      | `Stringlit of string\n      | `Tuple of json sexp_list\n      | `Variant of string * json sexp_option ]\n  type json_max = json\n  val to_string :\n    ?buf:Bi_outbuf.t -> ?len:int -> ?std:sexp_bool -> json_max -> string\n  val to_channel :\n    ?buf:Bi_outbuf.t ->\n    ?len:int -> ?std:sexp_bool -> Pervasives.out_channel -> json_max -> unit\n  val to_output :\n    ?buf:Bi_outbuf.t ->\n    ?len:int ->\n    ?std:sexp_bool ->\n    < output : string -> int -> int -> int; .. > -> json_max -> unit\n  val to_file : ?len:int -> ?std:sexp_bool -> string -> json_max -> unit\n  val to_outbuf : ?std:sexp_bool -> Bi_outbuf.t -> json_max -> unit\n  val stream_to_string :\n    ?buf:Bi_outbuf.t ->\n    ?len:int -> ?std:sexp_bool -> json_max Stream.t -> string\n  val stream_to_channel :\n    ?buf:Bi_outbuf.t ->\n    ?len:int ->\n    ?std:sexp_bool -> Pervasives.out_channel -> json_max Stream.t -> unit\n  val stream_to_file :\n    ?len:int -> ?std:sexp_bool -> string -> json_max Stream.t -> unit\n  val stream_to_outbuf :\n    ?std:sexp_bool -> Bi_outbuf.t -> json_max Stream.t -> unit\n  val sort : json_max -> json_max\n  val write_null : Bi_outbuf.t -> unit -> unit\n  val write_bool : Bi_outbuf.t -> sexp_bool -> unit\n  val write_int : Bi_outbuf.t -> int -> unit\n  val write_float : Bi_outbuf.t -> float -> unit\n  val write_std_float : Bi_outbuf.t -> float -> unit\n  val write_float_fast : Bi_outbuf.t -> float -> unit\n  val write_std_float_fast : Bi_outbuf.t -> float -> unit\n  val write_float_prec : int -> Bi_outbuf.t -> float -> unit\n  val write_std_float_prec : int -> Bi_outbuf.t -> float -> unit\n  val write_string : Bi_outbuf.t -> string -> unit\n  val write_intlit : Bi_outbuf.t -> string -> unit\n  val write_floatlit : Bi_outbuf.t -> string -> unit\n  val write_stringlit : Bi_outbuf.t -> string -> unit\n  val write_assoc : Bi_outbuf.t -> (string * json_max) sexp_list -> unit\n  val write_list : Bi_outbuf.t -> json_max sexp_list -> unit\n  val write_tuple : Bi_outbuf.t -> json_max sexp_list -> unit\n  val write_std_tuple : Bi_outbuf.t -> json_max sexp_list -> unit\n  val write_variant : Bi_outbuf.t -> string -> json_max sexp_option -> unit\n  val write_std_variant :\n    Bi_outbuf.t -> string -> json_max sexp_option -> unit\n  val write_json : Bi_outbuf.t -> json_max -> unit\n  val write_std_json : Bi_outbuf.t -> json_max -> unit\n  val pretty_format : ?std:sexp_bool -> json_max -> Easy_format.t\n  val pretty_print : ?std:sexp_bool -> Format.formatter -> json_max -> unit\n  val pretty_to_string : ?std:sexp_bool -> json_max -> string\n  val pretty_to_channel :\n    ?std:sexp_bool -> Pervasives.out_channel -> json_max -> unit\nend"}
{"start":{"line":67,"col":20},"end":{"line":67,"col":31},"type":"sig\n  type json =\n      [ `Assoc of (string * json) sexp_list\n      | `Bool of sexp_bool\n      | `Float of float\n      | `Int of int\n      | `Intlit of string\n      | `List of json sexp_list\n      | `Null\n      | `String of string\n      | `Tuple of json sexp_list\n      | `Variant of string * json sexp_option ]\n  val to_basic : json -> Yojson.Basic.json\n  val to_string :\n    ?buf:Bi_outbuf.t -> ?len:int -> ?std:sexp_bool -> json -> string\n  val to_channel :\n    ?buf:Bi_outbuf.t ->\n    ?len:int -> ?std:sexp_bool -> Pervasives.out_channel -> json -> unit\n  val to_output :\n    ?buf:Bi_outbuf.t ->\n    ?len:int ->\n    ?std:sexp_bool ->\n    < output : string -> int -> int -> int; .. > -> json -> unit\n  val to_file : ?len:int -> ?std:sexp_bool -> string -> json -> unit\n  val to_outbuf : ?std:sexp_bool -> Bi_outbuf.t -> json -> unit\n  val stream_to_string :\n    ?buf:Bi_outbuf.t -> ?len:int -> ?std:sexp_bool -> json Stream.t -> string\n  val stream_to_channel :\n    ?buf:Bi_outbuf.t ->\n    ?len:int ->\n    ?std:sexp_bool -> Pervasives.out_channel -> json Stream.t -> unit\n  val stream_to_file :\n    ?len:int -> ?std:sexp_bool -> string -> json Stream.t -> unit\n  val stream_to_outbuf :\n    ?std:sexp_bool -> Bi_outbuf.t -> json Stream.t -> unit\n  val sort : json -> json\n  val write_null : Bi_outbuf.t -> unit -> unit\n  val write_bool : Bi_outbuf.t -> sexp_bool -> unit\n  val write_int : Bi_outbuf.t -> int -> unit\n  val write_float : Bi_outbuf.t -> float -> unit\n  val write_std_float : Bi_outbuf.t -> float -> unit\n  val write_float_fast : Bi_outbuf.t -> float -> unit\n  val write_std_float_fast : Bi_outbuf.t -> float -> unit\n  val write_float_prec : int -> Bi_outbuf.t -> float -> unit\n  val write_std_float_prec : int -> Bi_outbuf.t -> float -> unit\n  val write_string : Bi_outbuf.t -> string -> unit\n  val write_intlit : Bi_outbuf.t -> string -> unit\n  val write_assoc : Bi_outbuf.t -> (string * json) sexp_list -> unit\n  val write_list : Bi_outbuf.t -> json sexp_list -> unit\n  val write_tuple : Bi_outbuf.t -> json sexp_list -> unit\n  val write_std_tuple : Bi_outbuf.t -> json sexp_list -> unit\n  val write_variant : Bi_outbuf.t -> string -> json sexp_option -> unit\n  val write_std_variant : Bi_outbuf.t -> string -> json sexp_option -> unit\n  val write_json : Bi_outbuf.t -> json -> unit\n  val write_std_json : Bi_outbuf.t -> json -> unit\n  val pretty_format : ?std:sexp_bool -> json -> Easy_format.t\n  val pretty_print : ?std:sexp_bool -> Format.formatter -> json -> unit\n  val pretty_to_string : ?std:sexp_bool -> json -> string\n  val pretty_to_channel :\n    ?std:sexp_bool -> Pervasives.out_channel -> json -> unit\n  val prettify : ?std:sexp_bool -> string -> string\n  val compact : ?std:sexp_bool -> string -> string\n  exception Finally of exn * exn\n  val from_string :\n    ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json\n  val from_channel :\n    ?buf:Bi_outbuf.t ->\n    ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json\n  val from_file :\n    ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json\n  type lexer_state =\n    Yojson.lexer_state = {\n    buf : Bi_outbuf.t;\n    mutable lnum : int;\n    mutable bol : int;\n    mutable fname : string sexp_option;\n  }\n  val init_lexer :\n    ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> unit -> lexer_state\n  val from_lexbuf : lexer_state -> ?stream:sexp_bool -> Lexing.lexbuf -> json\n  val stream_from_string :\n    ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json Stream.t\n  val stream_from_channel :\n    ?buf:Bi_outbuf.t ->\n    ?fin:(unit -> unit) ->\n    ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json Stream.t\n  val stream_from_file :\n    ?buf:Bi_outbuf.t -> ?fname:string -> ?lnum:int -> string -> json Stream.t\n  val stream_from_lexbuf :\n    lexer_state -> ?fin:(unit -> unit) -> Lexing.lexbuf -> json Stream.t\n  type json_line = [ `Exn of exn | `Json of json ]\n  val linestream_from_channel :\n    ?buf:Bi_outbuf.t ->\n    ?fin:(unit -> unit) ->\n    ?fname:string -> ?lnum:int -> Pervasives.in_channel -> json_line Stream.t\n  val linestream_from_file :\n    ?buf:Bi_outbuf.t ->\n    ?fname:string -> ?lnum:int -> string -> json_line Stream.t\n  val finish_string : lexer_state -> Lexing.lexbuf -> string\n  val read_string : lexer_state -> Lexing.lexbuf -> string\n  val read_ident : lexer_state -> Lexing.lexbuf -> string\n  val map_string :\n    lexer_state -> (string -> int -> int -> 'a) -> Lexing.lexbuf -> 'a\n  val map_ident :\n    lexer_state -> (string -> int -> int -> 'a) -> Lexing.lexbuf -> 'a\n  type variant_kind = [ `Double_quote | `Edgy_bracket | `Square_bracket ]\n  val start_any_variant : lexer_state -> Lexing.lexbuf -> variant_kind\n  val finish_variant : lexer_state -> Lexing.lexbuf -> json sexp_option\n  val finish_skip_variant : lexer_state -> Lexing.lexbuf -> unit\n  val read_lt : lexer_state -> Lexing.lexbuf -> unit\n  val read_gt : lexer_state -> Lexing.lexbuf -> unit\n  val read_comma : lexer_state -> Lexing.lexbuf -> unit\n  val finish_stringlit : lexer_state -> Lexing.lexbuf -> string\n  val finish_skip_stringlit : lexer_state -> Lexing.lexbuf -> unit\n  val finish_escaped_char : lexer_state -> Lexing.lexbuf -> unit\n  val finish_comment : lexer_state -> Lexing.lexbuf -> unit\n  val read_space : lexer_state -> Lexing.lexbuf -> unit\n  val read_eof : Lexing.lexbuf -> sexp_bool\n  val read_null : lexer_state -> Lexing.lexbuf -> unit\n  val read_null_if_possible : lexer_state -> Lexing.lexbuf -> sexp_bool\n  val read_bool : lexer_state -> Lexing.lexbuf -> sexp_bool\n  val read_int : lexer_state -> Lexing.lexbuf -> int\n  val read_int8 : lexer_state -> Lexing.lexbuf -> char\n  val read_int32 : lexer_state -> Lexing.lexbuf -> int32\n  val read_int64 : lexer_state -> Lexing.lexbuf -> int64\n  val read_number : lexer_state -> Lexing.lexbuf -> float\n  val skip_ident : lexer_state -> Lexing.lexbuf -> unit\n  val read_sequence :\n    ('a -> lexer_state -> Lexing.lexbuf -> 'a) ->\n    'a -> lexer_state -> Lexing.lexbuf -> 'a\n  val read_list :\n    (lexer_state -> Lexing.lexbuf -> 'a) ->\n    lexer_state -> Lexing.lexbuf -> 'a sexp_list\n  val read_list_rev :\n    (lexer_state -> Lexing.lexbuf -> 'a) ->\n    lexer_state -> Lexing.lexbuf -> 'a sexp_list\n  val read_array_end : Lexing.lexbuf -> unit\n  val read_array_sep : lexer_state -> Lexing.lexbuf -> unit\n  val read_array :\n    (lexer_state -> Lexing.lexbuf -> 'a) ->\n    lexer_state -> Lexing.lexbuf -> 'a array\n  val read_tuple :\n    (int -> 'a -> lexer_state -> Lexing.lexbuf -> 'a) ->\n    'a -> lexer_state -> Lexing.lexbuf -> 'a\n  val start_any_tuple : lexer_state -> Lexing.lexbuf -> sexp_bool\n  val read_lpar : lexer_state -> Lexing.lexbuf -> unit\n  val read_rpar : lexer_state -> Lexing.lexbuf -> unit\n  val read_tuple_end : Lexing.lexbuf -> unit\n  val read_tuple_end2 : lexer_state -> sexp_bool -> Lexing.lexbuf -> unit\n  val read_tuple_sep : lexer_state -> Lexing.lexbuf -> unit\n  val read_tuple_sep2 : lexer_state -> sexp_bool -> Lexing.lexbuf -> unit\n  val read_lbr : lexer_state -> Lexing.lexbuf -> unit\n  val read_rbr : lexer_state -> Lexing.lexbuf -> unit\n  val read_fields :\n    ('acc -> string -> lexer_state -> Lexing.lexbuf -> 'acc) ->\n    'acc -> lexer_state -> Lexing.lexbuf -> 'acc\n  val read_abstract_fields :\n    (lexer_state -> Lexing.lexbuf -> 'key) ->\n    ('acc -> 'key -> lexer_state -> Lexing.lexbuf -> 'acc) ->\n    'acc -> lexer_state -> Lexing.lexbuf -> 'acc\n  val read_lcurl : lexer_state -> Lexing.lexbuf -> unit\n  val read_object_end : Lexing.lexbuf -> unit\n  val read_object_sep : lexer_state -> Lexing.lexbuf -> unit\n  val read_colon : lexer_state -> Lexing.lexbuf -> unit\n  val read_json : lexer_state -> Lexing.lexbuf -> json\n  val skip_json : lexer_state -> Lexing.lexbuf -> unit\n  val buffer_json : lexer_state -> Lexing.lexbuf -> unit\n  val validate_json : 'path -> json -> 'error sexp_option\n  module Util :\n    sig\n      exception Type_error of string * json\n      exception Undefined of string * json\n      val ( |> ) : 'a -> ('a -> 'b) -> 'b\n      val keys : json -> string sexp_list\n      val values : json -> json sexp_list\n      val combine : json -> json -> json\n      val member : string -> json -> json\n      val index : int -> json -> json\n      val map : (json -> json) -> json -> json\n      val to_assoc : json -> (string * json) sexp_list\n      val to_option : (json -> 'a) -> json -> 'a sexp_option\n      val to_bool : json -> sexp_bool\n      val to_bool_option : json -> sexp_bool sexp_option\n      val to_number : json -> float\n      val to_number_option : json -> float sexp_option\n      val to_float : json -> float\n      val to_float_option : json -> float sexp_option\n      val to_int : json -> int\n      val to_int_option : json -> int sexp_option\n      val to_list : json -> json sexp_list\n      val to_string : json -> string\n      val to_string_option : json -> string sexp_option\n      val convert_each : (json -> 'a) -> json -> 'a sexp_list\n      val filter_map : ('a -> 'b sexp_option) -> 'a sexp_list -> 'b sexp_list\n      val flatten : json sexp_list -> json sexp_list\n      val filter_index : int -> json sexp_list -> json sexp_list\n      val filter_list : json sexp_list -> json sexp_list sexp_list\n      val filter_member : string -> json sexp_list -> json sexp_list\n      val filter_assoc :\n        json sexp_list -> (string * json) sexp_list sexp_list\n      val filter_bool : json sexp_list -> sexp_bool sexp_list\n      val filter_int : json sexp_list -> int sexp_list\n      val filter_float : json sexp_list -> float sexp_list\n      val filter_number : json sexp_list -> float sexp_list\n      val filter_string : json sexp_list -> string sexp_list\n    end\nend"}
{"start":{"line":67,"col":20},"end":{"line":67,"col":36},"definition":{"file":"/Users/rvt/.opam/default/lib/sexplib/type.ml","pos":{"line":3,"col":0}}}
{"start":{"line":67,"col":20},"end":{"line":67,"col":36},"definition":{"file":"/Users/rvt/.opam/default/lib/yojson/yojson.ml","pos":{"line":1,"col":0}}}
{"start":{"line":67,"col":20},"end":{"line":67,"col":36},"definition":{"file":"/Users/rvt/.opam/default/lib/yojson/yojson.ml","pos":{"line":46,"col":0}}}
{"start":{"line":67,"col":20},"end":{"line":67,"col":36},"type":"type json = Yojson.Safe.json"}
{"start":{"line":67,"col":4},"end":{"line":67,"col":13},"type":"(string, data, 'a) Base.Map.t -> Yojson.Safe.json"}
{"start":{"line":68,"col":2},"end":{"line":77,"col":18},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":68,"col":2},"end":{"line":79,"col":9},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":68,"col":2},"end":{"line":79,"col":9},"type":"Yojson.Safe.json"}
{"start":{"line":68,"col":6},"end":{"line":68,"col":7},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ] sexp_list"}
{"start":{"line":69,"col":19},"end":{"line":69,"col":22},"definition":{"file":"*buffer*","pos":{"line":67,"col":14}}}
{"start":{"line":69,"col":19},"end":{"line":69,"col":22},"type":"(string, data, 'a) Base.Map.t"}
{"start":{"line":69,"col":29},"end":{"line":69,"col":31},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ] sexp_list"}
{"start":{"line":69,"col":35},"end":{"line":77,"col":18},"type":"key:string ->\ndata:data ->\n([> `Assoc of (string * Yojson.Safe.json) sexp_list ] as 'a) sexp_list ->\n'a sexp_list"}
{"start":{"line":69,"col":45},"end":{"line":69,"col":53},"type":"string"}
{"start":{"line":69,"col":4},"end":{"line":69,"col":18},"definition":{"file":"/Users/rvt/.opam/default/lib/base/map.ml","pos":{"line":1289,"col":6}}}
{"start":{"line":69,"col":4},"end":{"line":69,"col":18},"type":"('k, 'v, 'b) Base.Map.t -> init:'a -> f:(key:'k -> data:'v -> 'a -> 'a) -> 'a"}
{"start":{"line":69,"col":4},"end":{"line":69,"col":7},"type":"(module Core.Map)"}
{"start":{"line":69,"col":4},"end":{"line":77,"col":18},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ] sexp_list"}
{"start":{"line":69,"col":54},"end":{"line":77,"col":17},"type":"data:data ->\n([> `Assoc of (string * Yojson.Safe.json) sexp_list ] as 'a) sexp_list ->\n'a sexp_list"}
{"start":{"line":69,"col":60},"end":{"line":69,"col":74},"type":"data"}
{"start":{"line":69,"col":61},"end":{"line":69,"col":66},"type":"string"}
{"start":{"line":69,"col":68},"end":{"line":69,"col":73},"type":"Range.t"}
{"start":{"line":69,"col":75},"end":{"line":69,"col":78},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ] sexp_list"}
{"start":{"line":69,"col":75},"end":{"line":77,"col":17},"type":"([> `Assoc of (string * Yojson.Safe.json) sexp_list ] as 'a) sexp_list ->\n'a sexp_list"}
{"start":{"line":70,"col":12},"end":{"line":70,"col":16},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ]"}
{"start":{"line":70,"col":8},"end":{"line":75,"col":13},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":70,"col":8},"end":{"line":77,"col":17},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ] sexp_list"}
{"start":{"line":71,"col":10},"end":{"line":75,"col":13},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ]"}
{"start":{"line":72,"col":12},"end":{"line":75,"col":13},"type":"(string * Yojson.Safe.json) sexp_list"}
{"start":{"line":72,"col":14},"end":{"line":72,"col":44},"type":"string * Yojson.Safe.json"}
{"start":{"line":72,"col":15},"end":{"line":72,"col":25},"definition":{"file":"*buffer*","pos":{"line":69,"col":45}}}
{"start":{"line":72,"col":15},"end":{"line":72,"col":25},"type":"string"}
{"start":{"line":72,"col":16},"end":{"line":72,"col":24},"type":"string"}
{"start":{"line":72,"col":27},"end":{"line":72,"col":43},"type":"Yojson.Safe.json"}
{"start":{"line":72,"col":35},"end":{"line":72,"col":43},"definition":{"file":"*buffer*","pos":{"line":69,"col":45}}}
{"start":{"line":72,"col":35},"end":{"line":72,"col":43},"type":"string"}
{"start":{"line":73,"col":14},"end":{"line":73,"col":38},"type":"string * Yojson.Safe.json"}
{"start":{"line":73,"col":14},"end":{"line":75,"col":13},"type":"(string * Yojson.Safe.json) sexp_list"}
{"start":{"line":73,"col":15},"end":{"line":73,"col":22},"definition":{"file":"*buffer*","pos":{"line":69,"col":61}}}
{"start":{"line":73,"col":15},"end":{"line":73,"col":22},"type":"string"}
{"start":{"line":73,"col":16},"end":{"line":73,"col":21},"type":"string"}
{"start":{"line":73,"col":24},"end":{"line":73,"col":37},"type":"Yojson.Safe.json"}
{"start":{"line":73,"col":32},"end":{"line":73,"col":37},"definition":{"file":"*buffer*","pos":{"line":69,"col":61}}}
{"start":{"line":73,"col":32},"end":{"line":73,"col":37},"type":"string"}
{"start":{"line":74,"col":14},"end":{"line":74,"col":46},"type":"string * Yojson.Safe.json"}
{"start":{"line":74,"col":14},"end":{"line":75,"col":13},"type":"(string * Yojson.Safe.json) sexp_list"}
{"start":{"line":74,"col":15},"end":{"line":74,"col":22},"definition":{"file":"*buffer*","pos":{"line":69,"col":68}}}
{"start":{"line":74,"col":15},"end":{"line":74,"col":22},"type":"string"}
{"start":{"line":74,"col":16},"end":{"line":74,"col":21},"type":"Range.t"}
{"start":{"line":74,"col":24},"end":{"line":74,"col":29},"type":"(module Range)"}
{"start":{"line":74,"col":24},"end":{"line":74,"col":39},"definition":{"file":"/Users/rvt/official-comby/lib/match/range.ml","pos":{"line":1,"col":0}}}
{"start":{"line":74,"col":24},"end":{"line":74,"col":39},"type":"Range.t -> Yojson.Safe.json"}
{"start":{"line":74,"col":40},"end":{"line":74,"col":45},"definition":{"file":"*buffer*","pos":{"line":69,"col":68}}}
{"start":{"line":74,"col":40},"end":{"line":74,"col":45},"type":"Range.t"}
{"start":{"line":75,"col":12},"end":{"line":75,"col":13},"type":"(string * Yojson.Safe.json) sexp_list"}
{"start":{"line":77,"col":14},"end":{"line":77,"col":17},"definition":{"file":"*buffer*","pos":{"line":69,"col":75}}}
{"start":{"line":77,"col":14},"end":{"line":77,"col":17},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ] sexp_list"}
{"start":{"line":77,"col":8},"end":{"line":77,"col":12},"definition":{"file":"*buffer*","pos":{"line":70,"col":12}}}
{"start":{"line":77,"col":8},"end":{"line":77,"col":12},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ]"}
{"start":{"line":77,"col":8},"end":{"line":77,"col":17},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ] sexp_list"}
{"start":{"line":79,"col":2},"end":{"line":79,"col":9},"type":"Yojson.Safe.json"}
{"start":{"line":79,"col":8},"end":{"line":79,"col":9},"definition":{"file":"*buffer*","pos":{"line":68,"col":6}}}
{"start":{"line":79,"col":8},"end":{"line":79,"col":9},"type":"[> `Assoc of (string * Yojson.Safe.json) sexp_list ] sexp_list"}
{"start":{"line":81,"col":14},"end":{"line":81,"col":15},"type":"'a"}
{"start":{"line":81,"col":14},"end":{"line":81,"col":30},"definition":{"file":"/Users/rvt/.opam/default/lib/ocaml/stdlib.ml","pos":{"line":57,"col":0}}}
{"start":{"line":81,"col":14},"end":{"line":81,"col":30},"type":"'a -> 'b"}
{"start":{"line":81,"col":18},"end":{"line":81,"col":30},"type":"'a"}
{"start":{"line":81,"col":25},"end":{"line":81,"col":30},"type":"sexp_bool"}
{"start":{"line":81,"col":4},"end":{"line":81,"col":13},"type":"'a -> 'b"}
{"class":"return","value":[],"notifications":[],"timing":{"clock":1194,"cpu":1076,"query":911,"pp":0,"reader":1,"ppx":34,"typer":131,"error":0}}
